<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="google-site-verification" content="FVeTimbT1kTEtyy7CZnjl87tv6Zu3gYnjspaqbsrZ6M" />
    <meta name="baidu-site-verification" content="codeva-4fIoJmJzzi" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="生成Android能动态加载的Jar包  这样可以直接build生成jar包，生成的jar包会在如下图片的路径下   具体项目里没显示也不知道为什么。如果想要更改成release版本只需在structure里   之后选择   将其改变为release即可   利用gradle打jar包 123456789101112131415task makeJar(type: Copy) &#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="Android基础">
<meta property="og:url" content="https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Oceanzbz&#39;s Blog">
<meta property="og:description" content="生成Android能动态加载的Jar包  这样可以直接build生成jar包，生成的jar包会在如下图片的路径下   具体项目里没显示也不知道为什么。如果想要更改成release版本只需在structure里   之后选择   将其改变为release即可   利用gradle打jar包 123456789101112131415task makeJar(type: Copy) &#123;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250409223354364.png">
<meta property="og:image" content="https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250409223745301.png">
<meta property="og:image" content="https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250409224400415.png">
<meta property="og:image" content="https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250409224441831.png">
<meta property="og:image" content="https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250409224503058.png">
<meta property="og:image" content="https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250409230213176.png">
<meta property="og:image" content="https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250409231641007.png">
<meta property="og:image" content="https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250409234915914.png">
<meta property="og:image" content="https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250409235243892.png">
<meta property="og:image" content="https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250412173543134.png">
<meta property="og:image" content="https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250412173630147.png">
<meta property="og:image" content="https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250413174113482.png">
<meta property="og:image" content="https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250416210943736.png">
<meta property="og:image" content="https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250416210954339.png">
<meta property="og:image" content="https://oceanzbz.cn/c00b8f3c09582f980182c47c971dc7bc_MD5.webp">
<meta property="og:image" content="https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250501184207452.png">
<meta property="og:image" content="https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250501184813781.png">
<meta property="og:image" content="https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250501184833285.png">
<meta property="article:published_time" content="2025-04-09T14:24:54.000Z">
<meta property="article:modified_time" content="2025-05-13T02:43:40.775Z">
<meta property="article:author" content="Oceanzbz">
<meta property="article:tag" content="开发">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250409223354364.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Android基础</title>
    <!-- async scripts -->
    <!-- Google Analytics -->

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-QWTJSPQL4F"></script>
  <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-QWTJSPQL4F');
  </script>


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="Oceanzbz&#39;s Blog" type="application/atom+xml" />
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/link/">Friends</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2025/05/10/%E6%94%BB%E9%98%B2%E6%B8%97%E9%80%8F/%E5%85%8D%E6%9D%80/badusb%E5%88%B6%E4%BD%9C/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2025/04/04/%E6%94%BB%E9%98%B2%E6%B8%97%E9%80%8F/cyberstrikelab/CERT-1/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/&text=Android基础"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/&title=Android基础"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/&is_video=false&description=Android基础"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Android基础&body=Check out this article: https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/&title=Android基础"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/&title=Android基础"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/&title=Android基础"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/&title=Android基础"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/&name=Android基础&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/&t=Android基础"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90Android%E8%83%BD%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E7%9A%84Jar%E5%8C%85"><span class="toc-number">1.</span> <span class="toc-text">生成Android能动态加载的Jar包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDJar%E5%8C%85"><span class="toc-number">2.</span> <span class="toc-text">动态加载Jar包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NDK%E7%BC%96%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">NDK编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JNI-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.1.</span> <span class="toc-text">JNI 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NDK-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.2.</span> <span class="toc-text">NDK 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JNI-%E4%B8%8E-NDK-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.3.</span> <span class="toc-text">JNI 与 NDK 的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AAJNI%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.4.</span> <span class="toc-text">第一个JNI程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.1.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.2.</span> <span class="toc-text">引用数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">3.5.3.</span> <span class="toc-text">数据类型描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">3.5.4.</span> <span class="toc-text">Java 引用类型描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JNI-%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.5.5.</span> <span class="toc-text">JNI 方法签名格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JNI%E6%96%B9%E6%B3%95"><span class="toc-number">3.6.</span> <span class="toc-text">JNI方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JNI%E6%B3%A8%E5%86%8C"><span class="toc-number">3.7.</span> <span class="toc-text">JNI注册</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%B3%A8%E5%86%8C"><span class="toc-number">3.7.1.</span> <span class="toc-text">静态注册</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C"><span class="toc-number">3.7.2.</span> <span class="toc-text">动态注册</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RegisterNatives%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="toc-number">3.7.2.1.</span> <span class="toc-text">RegisterNatives方法解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-mk-%E5%92%8C-CMake-%E8%AF%AD%E6%B3%95"><span class="toc-number">3.8.</span> <span class="toc-text">Android.mk 和 CMake 语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-Studio-%E4%B8%AD%E4%BD%BF%E7%94%A8-NDK"><span class="toc-number">3.9.</span> <span class="toc-text">Android Studio 中使用 NDK</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APK%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">APK文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#assets%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">4.1.</span> <span class="toc-text">assets文件夹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lib%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">4.2.</span> <span class="toc-text">lib文件夹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#META-INF%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">4.3.</span> <span class="toc-text">META-INF文件夹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AndroidManifest-xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">4.4.</span> <span class="toc-text">AndroidManifest.xml配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resources-arsc%E6%96%87%E4%BB%B6"><span class="toc-number">4.5.</span> <span class="toc-text">resources.arsc文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#res%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">4.6.</span> <span class="toc-text">res文件夹</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dex%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">dex文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string-ids"><span class="toc-number">5.1.</span> <span class="toc-text">string_ids</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-ids"><span class="toc-number">5.2.</span> <span class="toc-text">type_ids</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proto-ids"><span class="toc-number">5.3.</span> <span class="toc-text">proto_ids</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#field-ids"><span class="toc-number">5.4.</span> <span class="toc-text">field_ids</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#method-ids"><span class="toc-number">5.5.</span> <span class="toc-text">method_ids</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#class-def"><span class="toc-number">5.6.</span> <span class="toc-text">class_def</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DefCLassData"><span class="toc-number">5.6.1.</span> <span class="toc-text">DefCLassData</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DexField"><span class="toc-number">5.6.2.</span> <span class="toc-text">DexField</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DexMethod"><span class="toc-number">5.6.3.</span> <span class="toc-text">DexMethod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DexCode"><span class="toc-number">5.6.4.</span> <span class="toc-text">DexCode</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">6.</span> <span class="toc-text">ELF文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ELF-Header"><span class="toc-number">6.1.</span> <span class="toc-text">ELF Header</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Program-Header"><span class="toc-number">6.2.</span> <span class="toc-text">Program Header</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Base-Address"><span class="toc-number">6.2.1.</span> <span class="toc-text">Base Address</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#p-type"><span class="toc-number">6.2.2.</span> <span class="toc-text">p_type</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Section-Header"><span class="toc-number">6.3.</span> <span class="toc-text">Section Header</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sh-type"><span class="toc-number">6.3.1.</span> <span class="toc-text">sh_type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sh-flags"><span class="toc-number">6.3.2.</span> <span class="toc-text">sh_flags</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Program-Header-%E5%92%8C-Section-header%E5%8C%BA%E5%88%AB"><span class="toc-number">6.4.</span> <span class="toc-text">Program Header 和 Section header区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Smali%E6%B1%87%E7%BC%96"><span class="toc-number">7.</span> <span class="toc-text">Smali汇编</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.1.</span> <span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">7.2.</span> <span class="toc-text">类的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">7.3.</span> <span class="toc-text">函数声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">7.4.</span> <span class="toc-text">函数返回关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">7.5.</span> <span class="toc-text">构造函数声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">7.6.</span> <span class="toc-text">变量声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">7.7.</span> <span class="toc-text">常量声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">7.8.</span> <span class="toc-text">静态代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">7.9.</span> <span class="toc-text">函数调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E5%8F%96%E5%80%BC%E4%B8%8E%E8%B5%8B%E5%80%BC"><span class="toc-number">7.10.</span> <span class="toc-text">字段取值与赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Smali%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%96%E5%80%BC%E4%B8%8E%E8%B5%8B%E5%80%BC"><span class="toc-number">7.11.</span> <span class="toc-text">Smali数组的取值与赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Smali%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA"><span class="toc-number">7.12.</span> <span class="toc-text">Smali对象创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Smali%E5%B8%B8%E9%87%8F%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89"><span class="toc-number">7.13.</span> <span class="toc-text">Smali常量数据定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Smali%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">7.13.1.</span> <span class="toc-text">Smali字符串常量定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Smali%E5%AD%97%E8%8A%82%E7%A0%81%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">7.13.2.</span> <span class="toc-text">Smali字节码常量定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Smali%E6%95%B0%E5%80%BC%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">7.13.3.</span> <span class="toc-text">Smali数值常量定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Smali%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC"><span class="toc-number">7.14.</span> <span class="toc-text">Smali条件跳转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Smali%E9%80%BB%E8%BE%91%E5%BE%AA%E7%8E%AF"><span class="toc-number">7.15.</span> <span class="toc-text">Smali逻辑循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">7.16.</span> <span class="toc-text">寄存器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARM%E6%B1%87%E7%BC%96"><span class="toc-number">8.</span> <span class="toc-text">ARM汇编</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3"><span class="toc-number">8.1.</span> <span class="toc-text">寄存器详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">8.1.0.1.</span> <span class="toc-text">1. 通用寄存器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%B8%93%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">8.1.0.2.</span> <span class="toc-text">2. 专用寄存器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">8.1.0.3.</span> <span class="toc-text">3. 控制寄存器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-32%E4%BD%8D%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="toc-number">8.1.1.</span> <span class="toc-text">2.1 32位数据操作指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-32%E4%BD%8D%E5%AD%98%E5%82%A8%E5%99%A8%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-number">8.1.2.</span> <span class="toc-text">2.2 32位存储器数据传送指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-32%E4%BD%8D%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">8.1.3.</span> <span class="toc-text">2.3 32位转移指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E5%85%B6%E5%AE%8332%E4%BD%8D%E6%8C%87%E4%BB%A4"><span class="toc-number">8.1.4.</span> <span class="toc-text">2.4 其它32位指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E7%AB%8B%E5%8D%B3%E6%95%B0"><span class="toc-number">8.1.5.</span> <span class="toc-text">2.5 立即数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E9%80%BB%E8%BE%91%E6%95%B0"><span class="toc-number">8.1.6.</span> <span class="toc-text">2.6 逻辑数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E5%92%8C%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="toc-number">8.1.7.</span> <span class="toc-text">2.7 逻辑运算和算术运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3"><span class="toc-number">8.2.</span> <span class="toc-text">实例讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-MRS"><span class="toc-number">8.2.1.</span> <span class="toc-text">3.1 MRS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-MSR"><span class="toc-number">8.2.2.</span> <span class="toc-text">3.2 MSR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-PRIMASK"><span class="toc-number">8.2.3.</span> <span class="toc-text">3.3 PRIMASK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-FAULTMASK"><span class="toc-number">8.2.4.</span> <span class="toc-text">3.4 FAULTMASK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-BX%E6%8C%87%E4%BB%A4"><span class="toc-number">8.2.5.</span> <span class="toc-text">3.5 BX指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E9%9B%B6%E5%AF%84%E5%AD%98%E5%99%A8-wzr%E3%80%81xzr"><span class="toc-number">8.2.6.</span> <span class="toc-text">3.6 零寄存器 wzr、xzr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80%E6%8C%87%E4%BB%A4MOV"><span class="toc-number">8.2.7.</span> <span class="toc-text">3.7 立即寻址指令MOV</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%8C%87%E4%BB%A4LDR"><span class="toc-number">8.2.8.</span> <span class="toc-text">3.8 寄存器间接寻址指令LDR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-%E5%AF%84%E5%AD%98%E5%99%A8%E7%A7%BB%E4%BD%8D%E5%AF%BB%E5%9D%80%E6%8C%87%E4%BB%A4LSL"><span class="toc-number">8.2.9.</span> <span class="toc-text">3.9 寄存器移位寻址指令LSL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80%E6%8C%87%E4%BB%A4-STR"><span class="toc-number">8.2.10.</span> <span class="toc-text">3.10 基址寻址指令 STR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-%E5%A4%9A%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">8.2.11.</span> <span class="toc-text">3.11 多寄存器寻址指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BBB%EF%BC%8CBAL"><span class="toc-number">8.2.12.</span> <span class="toc-text">3.12 无条件转移B，BAL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13-%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BBB-cont"><span class="toc-number">8.2.13.</span> <span class="toc-text">3.13 条件转移B.cont</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-14-WFE-%E5%92%8C-WFI-%E5%AF%B9%E6%AF%94"><span class="toc-number">8.2.14.</span> <span class="toc-text">3.14 WFE 和 WFI 对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-15-MRC%EF%BC%9A%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%B0ARM%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-number">8.2.15.</span> <span class="toc-text">3.15 MRC：协处理器寄存器到ARM寄存器的数据传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-16-MCR%EF%BC%9A%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%B0%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-number">8.2.16.</span> <span class="toc-text">3.16 MCR：寄存器到协处理器寄存器的数据传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-17-STM%EF%BC%9A%E5%B0%86%E6%8C%87%E4%BB%A4%E4%B8%AD%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%90%84%E5%AF%84%E5%AD%98%E5%99%A8%E6%95%B0%E5%80%BC%E5%86%99%E5%85%A5%E5%88%B0%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83%E4%B8%AD"><span class="toc-number">8.2.17.</span> <span class="toc-text">3.17 STM：将指令中寄存器列表中的各寄存器数值写入到连续的内存单元中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-18-LDM%EF%BC%9A%E5%B0%86%E6%95%B0%E6%8D%AE%E4%BB%8E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%88%B0%E6%8C%87%E4%BB%A4%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%90%84%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD"><span class="toc-number">8.2.18.</span> <span class="toc-text">3.18 LDM：将数据从连续内存单元中读取到指令的寄存器列表中的各寄存器中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-19-LDR%EF%BC%9A%E4%BB%8E%E5%86%85%E5%AD%98%E4%B8%AD%E5%B0%86%E4%B8%80%E4%B8%AA32%E4%BD%8D%E7%9A%84%E5%AD%97%E8%AF%BB%E5%8F%96%E5%88%B0%E7%9B%AE%E6%A0%87%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">8.2.19.</span> <span class="toc-text">3.19 LDR：从内存中将一个32位的字读取到目标寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-20-STR%EF%BC%9A%E5%B0%8632%E4%BD%8D%E5%AD%97%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9A%84%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83"><span class="toc-number">8.2.20.</span> <span class="toc-text">3.20 STR：将32位字数据写入到指定的内存单元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-21-SWI%EF%BC%9A%E8%BD%AF%E4%B8%AD%E6%96%AD%E6%8C%87%E4%BB%A4"><span class="toc-number">8.2.21.</span> <span class="toc-text">3.21 SWI：软中断指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-22-BIC%E6%B8%85%E9%99%A4%E4%BD%8D"><span class="toc-number">8.2.22.</span> <span class="toc-text">3.22 BIC清除位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-23-EOR%E9%80%BB%E8%BE%91%E5%BC%82%E6%88%96%E6%8C%87%E4%BB%A4"><span class="toc-number">8.2.23.</span> <span class="toc-text">3.23 EOR逻辑异或指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-24-CMN%E4%B8%8E%E8%B4%9F%E6%95%B0%E5%AF%B9%E6%AF%94"><span class="toc-number">8.2.24.</span> <span class="toc-text">3.24 CMN与负数对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-25-MVN%E5%8F%96%E5%8F%8D"><span class="toc-number">8.2.25.</span> <span class="toc-text">3.25 MVN取反</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-26-LSL%EF%BC%88Logical-Shift-Left%EF%BC%89%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97"><span class="toc-number">8.2.26.</span> <span class="toc-text">3.26 LSL（Logical Shift Left）左移运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-27-STP"><span class="toc-number">8.2.27.</span> <span class="toc-text">3.27 STP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90"><span class="toc-number">8.3.</span> <span class="toc-text">实例解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E5%9F%BA%E7%A1%80"><span class="toc-number">9.</span> <span class="toc-text">Android系统源码基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-number">9.1.</span> <span class="toc-text">系统架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">9.1.1.</span> <span class="toc-text">应用层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6%E5%B1%82"><span class="toc-number">9.1.2.</span> <span class="toc-text">应用框架层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E5%BA%93%E5%B1%82"><span class="toc-number">9.1.3.</span> <span class="toc-text">系统运行库层</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Android-Runtime%EF%BC%88ART%EF%BC%89"><span class="toc-number">9.1.3.1.</span> <span class="toc-text">Android Runtime（ART）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-C-%E5%8E%9F%E7%94%9F%E5%BA%93%EF%BC%88Native-Libraries%EF%BC%89"><span class="toc-number">9.1.3.2.</span> <span class="toc-text">C&#x2F;C++ 原生库（Native Libraries）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%8A%BD%E8%B1%A1%E5%B1%82"><span class="toc-number">9.1.4.</span> <span class="toc-text">硬件抽象层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E5%86%85%E6%A0%B8%E5%B1%82"><span class="toc-number">9.1.5.</span> <span class="toc-text">Linux内核层</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">9.2.</span> <span class="toc-text">源码目录结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Frida-%E4%BD%BF%E7%94%A8"><span class="toc-number">10.</span> <span class="toc-text">Frida 使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC%E6%B3%A8%E5%85%A5%E5%88%B0Android%E7%9B%AE%E6%A0%87%E8%BF%9B%E7%A8%8B"><span class="toc-number">10.1.</span> <span class="toc-text">将一个脚本注入到Android目标进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hook-Java"><span class="toc-number">10.2.</span> <span class="toc-text">Hook Java</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">10.2.1.</span> <span class="toc-text">带参数的构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">10.2.2.</span> <span class="toc-text">无参数构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E5%87%BD%E6%95%B0"><span class="toc-number">10.2.3.</span> <span class="toc-text">一般函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">10.2.4.</span> <span class="toc-text">无参数的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">10.2.5.</span> <span class="toc-text">调用函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E6%93%8D%E4%BD%9C"><span class="toc-number">10.2.6.</span> <span class="toc-text">字段操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">10.2.7.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-available%E5%AD%97%E6%AE%B5"><span class="toc-number">10.2.8.</span> <span class="toc-text">Java.available字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-perform%E6%96%B9%E6%B3%95"><span class="toc-number">10.2.9.</span> <span class="toc-text">Java.perform方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hook-Native"><span class="toc-number">10.3.</span> <span class="toc-text">Hook Native</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Hook-Native%E5%B1%82%E4%B8%AD%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%B9%B6%E4%B8%94%E8%AF%BB%E5%8F%96%E4%BC%A0%E5%85%A5%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">10.3.1.</span> <span class="toc-text">Hook Native层中调用的函数并且读取传入的参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hook%E4%BF%AE%E6%94%B9native%E5%B1%82%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">10.3.2.</span> <span class="toc-text">Hook修改native层程序返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8native%E5%B1%82%E4%B8%AD%E6%9C%AA%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">10.3.3.</span> <span class="toc-text">调用native层中未被调用的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8native%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">10.3.4.</span> <span class="toc-text">主动调用native中的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E5%A0%86%E6%A0%88"><span class="toc-number">10.3.5.</span> <span class="toc-text">打印堆栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8frida-%E8%BF%BD%E8%B8%AAjni%E5%87%BD%E6%95%B0%E5%8A%A8%E9%9D%99%E6%80%81%E6%B3%A8%E5%86%8C"><span class="toc-number">10.3.6.</span> <span class="toc-text">使用frida 追踪jni函数动静态注册</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        Android基础
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Oceanzbz</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-04-09T14:24:54.000Z" class="dt-published" itemprop="datePublished">2025-04-09</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/%E5%BC%80%E5%8F%91/">开发</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/Android/" rel="tag">Android</a>, <a class="p-category" href="/tags/%E5%BC%80%E5%8F%91/" rel="tag">开发</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h2 id="生成Android能动态加载的Jar包"><a href="#生成Android能动态加载的Jar包" class="headerlink" title="生成Android能动态加载的Jar包"></a>生成Android能动态加载的Jar包</h2><img src="/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250409223354364.png" class="">

<p>这样可以直接build生成jar包，生成的jar包会在如下图片的路径下</p>
<img src="/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250409223745301.png" class="">

<p>具体项目里没显示也不知道为什么。如果想要更改成release版本只需在structure里</p>
<img src="/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250409224400415.png" class="">

<p>之后选择</p>
<img src="/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250409224441831.png" class="">

<p>将其改变为release即可</p>
<img src="/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250409224503058.png" class="">

<p>利用gradle打jar包</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">task <span class="title function_">makeJar</span>(<span class="params">type: Copy</span>) &#123;</span><br><span class="line">    <span class="comment">//删除存在的</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="string">&#x27;build/libs/myjar.jar&#x27;</span></span><br><span class="line">    <span class="comment">//设置拷贝的文件</span></span><br><span class="line">    <span class="title function_">from</span>(<span class="string">&#x27;build/intermediates/aar_main_jar/release/&#x27;</span>)</span><br><span class="line">    <span class="comment">//打进jar包后的文件目录</span></span><br><span class="line">    <span class="title function_">into</span>(<span class="string">&#x27;build/libs/&#x27;</span>)</span><br><span class="line">    <span class="comment">//将classes.jar放入build/libs/目录下</span></span><br><span class="line">    <span class="comment">//include ,exclude参数来设置过滤</span></span><br><span class="line">    <span class="title function_">include</span>(<span class="string">&#x27;classes.jar&#x27;</span>)</span><br><span class="line">    <span class="comment">//重命名</span></span><br><span class="line">    <span class="title function_">rename</span> (<span class="string">&#x27;classes.jar&#x27;</span>, <span class="string">&#x27;myjar.jar&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeJar.<span class="title function_">dependsOn</span>(build)</span><br></pre></td></tr></table></figure>

<p>然后在命令行输入 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew makeJar</span><br></pre></td></tr></table></figure>

<p>或者直接点击运行也行</p>
<img src="/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250409230213176.png" class="">

<p>之后可以利用d8 将生成的jar包提取到桌面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d8 --dex --output=test.jar /Users/ocean/Cybersecurity/Android_Project/Study_Android/creatJar/build/intermediates/aar_main_jar/release/syncReleaseLibJars/classs.jar</span><br></pre></td></tr></table></figure>
<h2 id="动态加载Jar包"><a href="#动态加载Jar包" class="headerlink" title="动态加载Jar包"></a>动态加载Jar包</h2><p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/fengyulinde/article/details/79623743">https://blog.csdn.net/fengyulinde/article/details/79623743</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012121105/article/details/129297666">https://blog.csdn.net/u012121105/article/details/129297666</a></p>
<p>这里主要记录下重要的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lgf.dynamicload.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Environment;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lgf.plugin.IDynamic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dalvik.system.DexClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// layout相应的View中使用onClick属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMessage</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        <span class="comment">// 此路径为插件存放路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">dexPathFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(Environment.getExternalStorageDirectory() + File.separator + <span class="string">&quot;plugin.jar&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">dexPath</span> <span class="operator">=</span> dexPathFile.getAbsolutePath();</span><br><span class="line">        <span class="type">String</span> <span class="variable">dexDecompressPath</span> <span class="operator">=</span> getDir(<span class="string">&quot;dex&quot;</span>, MODE_PRIVATE).getAbsolutePath(); <span class="comment">// dex解压后的路径</span></span><br><span class="line"><span class="comment">//        String dexDecompressPath = Environment.getExternalStorageDirectory().getAbsolutePath(); // 不能放在SD卡下，否则会报错</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * DexClassLoader参数说明</span></span><br><span class="line"><span class="comment">         * 参数1 dexPath：待加载的dex文件路径，如果是外存路径，一定要加上读外存文件的权限（&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt; ）</span></span><br><span class="line"><span class="comment">         * 参数2 optimizedDirectory：解压后的dex存放位置，此位置一定要是可读写且仅该应用可读写（安全性考虑），所以只能放在data/data下。本文getDir(&quot;dex&quot;, MODE_PRIVATE)会在/data/data/**package/下创建一个名叫”app_dex1“的文件夹，其内存放的文件是自动生成output.dex；如果不满足条件，Android会报错误</span></span><br><span class="line"><span class="comment">         * 参数3 libraryPath：指向包含本地库(so)的文件夹路径，可以设为null</span></span><br><span class="line"><span class="comment">         * 参数4 parent：父级类加载器，一般可以通过Context.getClassLoader获取到，也可以通过ClassLoader.getSystemClassLoader()获取到。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">DexClassLoader</span> <span class="variable">dexClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DexClassLoader</span>(dexPath, dexDecompressPath, <span class="literal">null</span>, getClassLoader());</span><br><span class="line">        <span class="type">Class</span> <span class="variable">libClazz</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            libClazz = dexClassLoader.loadClass(<span class="string">&quot;com.lgf.base.DynamicTest&quot;</span>);</span><br><span class="line">            <span class="type">IDynamic</span> <span class="variable">lib</span> <span class="operator">=</span> (IDynamic) libClazz.newInstance();</span><br><span class="line">            Toast.makeText(<span class="built_in">this</span>, lib.show(), Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>记得添加下权限</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="NDK编程"><a href="#NDK编程" class="headerlink" title="NDK编程"></a>NDK编程</h2><h3 id="JNI-是什么"><a href="#JNI-是什么" class="headerlink" title="JNI 是什么"></a>JNI 是什么</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JNI 是 Java Native Interface 的缩写，即 Java 的本地接口。</span><br><span class="line">目的是使得 Java 与本地其他语言（如 C/C++）进行交互。</span><br><span class="line">JNI 是属于 Java 的，与 Android 无直接关系。</span><br></pre></td></tr></table></figure>

<h3 id="NDK-是什么"><a href="#NDK-是什么" class="headerlink" title="NDK 是什么"></a>NDK 是什么</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NDK 是 Native Development Kit 的缩写，是 Android 的工具开发包。</span><br><span class="line">作用是快速开发 C/C++ 的动态库，并自动将动态库与应用一起打包到 apk。</span><br><span class="line">NDK 是属于 Android 的，与 Java 无直接关系。</span><br></pre></td></tr></table></figure>

<h3 id="JNI-与-NDK-的关系"><a href="#JNI-与-NDK-的关系" class="headerlink" title="JNI 与 NDK 的关系"></a>JNI 与 NDK 的关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JNI 是实现的目的，NDK 是 Android 中实现 JNI 的手段。</span><br></pre></td></tr></table></figure>
<h3 id="第一个JNI程序"><a href="#第一个JNI程序" class="headerlink" title="第一个JNI程序"></a>第一个JNI程序</h3><p>新建一个c++Native程序，Android Studio 会自动帮你生成一个可执行的 Hello World 程序，我们简单看一下这个工程</p>
<img src="/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250409231641007.png" class="">

<p>其中 cpp 目录就是我们的 C&#x2F;C++ 代码、预编译库的默认路径了，而 CMakeList.txt 就是编译的脚本文件了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.ndkstudy;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;  </span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.example.ndkstudy.databinding.ActivityMainBinding;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Used to load the &#x27;ndkstudy&#x27; library on application startup.  </span></span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        System.loadLibrary(<span class="string">&quot;ndkstudy&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> ActivityMainBinding binding;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);  </span><br><span class="line">  </span><br><span class="line">        binding = ActivityMainBinding.inflate(getLayoutInflater());  </span><br><span class="line">        setContentView(binding.getRoot());  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Example of a call to a native method  </span></span><br><span class="line">        <span class="type">TextView</span> <span class="variable">tv</span> <span class="operator">=</span> binding.sampleText;  </span><br><span class="line">        tv.setText(stringFromJNI());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * A native method that is implemented by the &#x27;ndkstudy&#x27; native library,     * which is packaged with this application.     */</span>    <span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">stringFromJNI</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 调用本地方法，是使用 native 关键字。而本例中，本地方法的实现是在一个叫做 “native-lib” 的动态库里（动态库的名称是在 CMakeList.txt 中指定的），要想使用这个动态库，就必须先加载这个库，即 System.loadLibrary(native-lib) 。这些都是 Java 的语法定义。</p>
<p>看一下cpp的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> JNIEXPORT jstring JNICALL  </span><br><span class="line"><span class="title function_">Java_com_example_ndkstudy_MainActivity_stringFromJNI</span><span class="params">(  </span></span><br><span class="line"><span class="params">        JNIEnv* env,  </span></span><br><span class="line"><span class="params">        jobject <span class="comment">/* this */</span>)</span> &#123;  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> hello = <span class="string">&quot;Hello from C++&quot;</span>;  </span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(hello.c_str());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  上面提到的 public native String stringFromJNI() 方法的实现就是在这里，那怎么知道 Java 中的某个 native 方法是对应的 cpp 中的哪个方法呢？这就和 JNI 的注册有关了，本例中使用的是静态注册，即 “Java包名类名_方法名” 的形式，其中包名也是用下划线替代点号。</p>
<p>总结下流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.Gradle 调用您的外部构建脚本 CMakeLists.txt。</span><br><span class="line">2.CMake 按照构建脚本中的命令将 C++ 源文件 native-lib.cpp 编译到共享的对象库中，并命名为 libnative-lib.so，Gradle 随后会将其打包到 APK 中。</span><br><span class="line">3.运行时，应用的 MainActivity 会使用 System.loadLibrary() 加载原生库。现在，应用可以使用库的原生函数 stringFromJNI()。</span><br><span class="line">4.MainActivity.onCreate() 调用 stringFromJNI()，这将返回“Hello from C++”并使用这些文字更新 TextView。</span><br></pre></td></tr></table></figure>

<p>在列一下CMakeLists.txt</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.22</span>.<span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line"># Declares the project name. The project name can be accessed via $&#123; PROJECT_NAME&#125;,  </span><br><span class="line"># Since this is the top level CMakeLists.txt, the project name is also accessible  </span><br><span class="line"><span class="meta"># with $&#123;CMAKE_PROJECT_NAME&#125; (both CMake variables are in-sync within the top level  </span></span><br><span class="line"><span class="meta"># build script scope).  </span></span><br><span class="line">project(<span class="string">&quot;ndkstudy&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"># Creates and names a library, sets it as either STATIC  </span><br><span class="line"><span class="meta"># or SHARED, and provides the relative paths to its source code.  </span></span><br><span class="line"># You can define multiple libraries, and CMake builds them <span class="keyword">for</span> you.  </span><br><span class="line"># Gradle automatically packages shared libraries with your APK.  </span><br><span class="line">#  </span><br><span class="line"># In this top level CMakeLists.txt, $&#123;CMAKE_PROJECT_NAME&#125; is used to define  </span><br><span class="line"><span class="meta"># the target library name; in the sub-module<span class="string">&#x27;s CMakeLists.txt, $&#123;PROJECT_NAME&#125;  </span></span></span><br><span class="line"><span class="string"><span class="meta"># is preferred for the same purpose.  </span></span></span><br><span class="line"><span class="string"><span class="meta">#  </span></span></span><br><span class="line"><span class="string"><span class="meta"># In order to load a library into your app from Java/Kotlin, you must call  </span></span></span><br><span class="line"><span class="string"><span class="meta"># System.loadLibrary() and pass the name of the library defined here;  </span></span></span><br><span class="line"><span class="string"><span class="meta"># for GameActivity/NativeActivity derived applications, the same library name must be  </span></span></span><br><span class="line"><span class="string"><span class="meta"># used in the AndroidManifest.xml file.  </span></span></span><br><span class="line"><span class="string"><span class="meta">add_library($&#123;CMAKE_PROJECT_NAME&#125; SHARED  </span></span></span><br><span class="line"><span class="string"><span class="meta">        # List C/C++ source files with relative paths to this CMakeLists.txt.  </span></span></span><br><span class="line"><span class="string"><span class="meta">        native-lib.cpp)  </span></span></span><br><span class="line"><span class="string"><span class="meta">  </span></span></span><br><span class="line"><span class="string"><span class="meta"># Specifies libraries CMake should link to your target library. You  </span></span></span><br><span class="line"><span class="string"><span class="meta"># can link libraries from various origins, such as libraries defined in this  </span></span></span><br><span class="line"><span class="string"><span class="meta"># build script, prebuilt third-party libraries, or Android system libraries.  </span></span></span><br><span class="line"><span class="string"><span class="meta">target_link_libraries($&#123;CMAKE_PROJECT_NAME&#125;  </span></span></span><br><span class="line"><span class="string"><span class="meta">        # List libraries link to the target library  </span></span></span><br><span class="line"><span class="string"><span class="meta">        android  </span></span></span><br><span class="line"><span class="string"><span class="meta">        log)</span></span></span><br></pre></td></tr></table></figure>

<p>解释下含义用gpt</p>
<p> cmake_minimum_required(VERSION 3.22.1)&#96;</p>
<ul>
<li><strong>含义</strong>：声明本项目使用的最低 CMake 版本是 <code>3.22.1</code>。这是为了确保 CMake 的语法和功能版本兼容。</li>
</ul>
<p><code>project(&quot;ndkstudy&quot;)</code></p>
<ul>
<li><p><strong>含义</strong>：定义项目名称为 <code>ndkstudy</code>。</p>
</li>
<li><p><strong>作用</strong>：</p>
<ul>
<li><p>会设置变量 <code>PROJECT_NAME</code> 为 <code>ndkstudy</code>；</p>
</li>
<li><p>在顶层 <code>CMakeLists.txt</code> 中，<code>PROJECT_NAME</code> 与 <code>CMAKE_PROJECT_NAME</code> 是一样的；</p>
</li>
<li><p>这个名称也通常被用作生成库文件的前缀，例如生成 <code>libndkstudy.so</code>。</p>
</li>
</ul>
</li>
</ul>
<p><code>add_library($&#123;CMAKE_PROJECT_NAME&#125; SHARED native-lib.cpp)</code></p>
<ul>
<li><p><strong>含义</strong>：</p>
<ul>
<li><p>创建一个共享库（<code>SHARED</code>），名字就是上面定义的项目名 <code>ndkstudy</code>；</p>
</li>
<li><p>包含一个源文件 <code>native-lib.cpp</code>，即这个库的源代码；</p>
</li>
</ul>
</li>
<li><p><strong>结果</strong>：</p>
<ul>
<li>会构建出一个名为 <code>libndkstudy.so</code> 的共享库。</li>
</ul>
</li>
</ul>
<p><code>target_link_libraries($&#123;CMAKE_PROJECT_NAME&#125; android log)</code></p>
<ul>
<li><p><strong>含义</strong>：</p>
<ul>
<li><p>为这个原生库链接上其他的依赖库：</p>
</li>
<li><p><code>android</code>: Android 原生 API；</p>
</li>
<li><p><code>log</code>: 用于调用 Android 的日志系统（如 <code>__android_log_print</code>）；</p>
</li>
</ul>
</li>
<li><p><strong>效果</strong>：</p>
<ul>
<li>可以在 <code>native-lib.cpp</code> 中使用 Android 系统的功能，例如打印 log 信息。</li>
</ul>
</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><table>
<thead>
<tr>
<th>Java 数据类型</th>
<th>JNI 本地类型</th>
<th>C&#x2F;C++ 数据类型</th>
<th>数据类型描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>jboolean</code></td>
<td><code>unsigned char</code></td>
<td>C&#x2F;C++ 无符号 8 位整数</td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>jbyte</code></td>
<td><code>signed char</code></td>
<td>C&#x2F;C++ 有符号 8 位整数</td>
</tr>
<tr>
<td><code>char</code></td>
<td><code>jchar</code></td>
<td><code>unsigned short</code></td>
<td>C&#x2F;C++ 无符号 16 位整数</td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>jshort</code></td>
<td><code>signed short</code></td>
<td>C&#x2F;C++ 有符号 16 位整数</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>jint</code></td>
<td><code>signed int</code></td>
<td>C&#x2F;C++ 有符号 32 位整数</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>jlong</code></td>
<td><code>signed long</code></td>
<td>C&#x2F;C++ 有符号 64 位整数</td>
</tr>
<tr>
<td><code>float</code></td>
<td><code>jfloat</code></td>
<td><code>float</code></td>
<td>C&#x2F;C++ 32 位浮点数</td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>jdouble</code></td>
<td><code>double</code></td>
<td>C&#x2F;C++ 64 位浮点数</td>
</tr>
</tbody></table>
<p>上表显示了java对应的c的数据类型使用JNI进行中转</p>
<h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>以下是你<strong>Java 类类型 与 JNI 引用类型</strong> 的对应关系</p>
<table>
<thead>
<tr>
<th>Java 类类型</th>
<th>JNI 引用类型</th>
<th>类型描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>java.lang.Object</code></td>
<td><code>jobject</code></td>
<td>表示任何 Java 对象，或没有特定 JNI 类型的对象（实例方法参数）</td>
</tr>
<tr>
<td><code>java.lang.String</code></td>
<td><code>jstring</code></td>
<td>Java 的 <code>String</code> 字符串对象</td>
</tr>
<tr>
<td><code>java.lang.Class</code></td>
<td><code>jclass</code></td>
<td>Java 的 <code>Class</code> 类型对象（用于静态方法的强制参数）</td>
</tr>
<tr>
<td><code>Object[]</code></td>
<td><code>jobjectArray</code></td>
<td>Java 中任意对象数组的表示形式</td>
</tr>
<tr>
<td><code>boolean[]</code></td>
<td><code>jbooleanArray</code></td>
<td>Java 基本类型 <code>boolean</code> 的数组表示形式</td>
</tr>
<tr>
<td><code>byte[]</code></td>
<td><code>jbyteArray</code></td>
<td>Java 基本类型 <code>byte</code> 的数组表示形式</td>
</tr>
<tr>
<td><code>char[]</code></td>
<td><code>jcharArray</code></td>
<td>Java 基本类型 <code>char</code> 的数组表示形式</td>
</tr>
<tr>
<td><code>short[]</code></td>
<td><code>jshortArray</code></td>
<td>Java 基本类型 <code>short</code> 的数组表示形式</td>
</tr>
<tr>
<td><code>int[]</code></td>
<td><code>jintArray</code></td>
<td>Java 基本类型 <code>int</code> 的数组表示形式</td>
</tr>
<tr>
<td><code>long[]</code></td>
<td><code>jlongArray</code></td>
<td>Java 基本类型 <code>long</code> 的数组表示形式</td>
</tr>
<tr>
<td><code>float[]</code></td>
<td><code>jfloatArray</code></td>
<td>Java 基本类型 <code>float</code> 的数组表示形式</td>
</tr>
<tr>
<td><code>double[]</code></td>
<td><code>jdoubleArray</code></td>
<td>Java 基本类型 <code>double</code> 的数组表示形式</td>
</tr>
<tr>
<td><code>java.lang.Throwable</code></td>
<td><code>jthrowable</code></td>
<td>Java 的异常类型，包括所有子类</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>void</code></td>
<td>无返回值（用于 JNI 方法返回类型）</td>
</tr>
</tbody></table>
<h4 id="数据类型描述符"><a href="#数据类型描述符" class="headerlink" title="数据类型描述符"></a>数据类型描述符</h4><table>
<thead>
<tr>
<th>Java 类型</th>
<th>JNI 类型描述符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>I</code></td>
<td>整型</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>J</code></td>
<td>长整型</td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>B</code></td>
<td>字节型</td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>S</code></td>
<td>短整型</td>
</tr>
<tr>
<td><code>char</code></td>
<td><code>C</code></td>
<td>字符型（UTF-16）</td>
</tr>
<tr>
<td><code>float</code></td>
<td><code>F</code></td>
<td>单精度浮点型</td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>D</code></td>
<td>双精度浮点型</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>Z</code></td>
<td>布尔型</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>V</code></td>
<td>无返回值</td>
</tr>
</tbody></table>
<h4 id="Java-引用类型描述符"><a href="#Java-引用类型描述符" class="headerlink" title="Java 引用类型描述符"></a>Java 引用类型描述符</h4><table>
<thead>
<tr>
<th>Java 类型</th>
<th>JNI 类型描述符</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>引用类型（类）</td>
<td><code>L&lt;类的全限定名&gt;;</code></td>
<td><code>Ljava/lang/String;</code> 表示 <code>String</code></td>
</tr>
<tr>
<td>数组类型（任意维度）</td>
<td><code>[</code> + 元素类型描述符</td>
<td><code>[I</code> 表示 <code>int[]</code>，<code>[Ljava/lang/String;</code> 表示 <code>String[]</code></td>
</tr>
</tbody></table>
<h4 id="JNI-方法签名格式"><a href="#JNI-方法签名格式" class="headerlink" title="JNI 方法签名格式"></a>JNI 方法签名格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数列表)返回值 </span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>示例 Java 方法签名</th>
<th>对应 JNI 方法描述符</th>
</tr>
</thead>
<tbody><tr>
<td><code>void foo()</code></td>
<td><code>()V</code></td>
</tr>
<tr>
<td><code>int sum(int a, int b)</code></td>
<td><code>(II)I</code></td>
</tr>
<tr>
<td><code>String concat(String a, String b)</code></td>
<td><code>(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</code></td>
</tr>
<tr>
<td><code>int[] getData()</code></td>
<td><code>()[I</code></td>
</tr>
<tr>
<td><code>void setValues(float[] values, boolean flag)</code></td>
<td><code>([FZ)V</code></td>
</tr>
</tbody></table>
<p>可以验证一下</p>
<img src="/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250409234915914.png" class="">

<p>可以看到我们定义的一个方法，编译一下之后用jabap看一下他的签名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -s com.example.ndkstudy.MainActivity</span><br></pre></td></tr></table></figure>

<img src="/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250409235243892.png" class="">

<p>符合表格的规则。来写一个读取scard目录的文件功能练习</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MY_PERMISSIONS_REQUEST_WRITE_CODE</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Used to load the &#x27;ndk01&#x27; library on application startup.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"></span><br><span class="line">System.loadLibrary(<span class="string">&quot;ndk01&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">testFun</span><span class="params">(String a, <span class="type">double</span> b, <span class="type">long</span> c)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ActivityMainBinding binding;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">binding = ActivityMainBinding.inflate(getLayoutInflater());</span><br><span class="line"></span><br><span class="line">setContentView(binding.getRoot());</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">testFun(<span class="string">&quot;aa&quot;</span>, <span class="number">4.5</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Example of a call to a native method</span></span><br><span class="line"></span><br><span class="line"><span class="type">TextView</span> <span class="variable">tv</span> <span class="operator">=</span> binding.sampleText;</span><br><span class="line"></span><br><span class="line">tv.setText(stringFromJNI());</span><br><span class="line"></span><br><span class="line">tv.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> ContextCompat.checkSelfPermission(MainActivity.<span class="built_in">this</span>, Manifest.permission.WRITE_EXTERNAL_STORAGE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret == PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line"></span><br><span class="line">Log.i(<span class="string">&quot;tttttttt&quot;</span>, <span class="string">&quot;已经有写SDCard的权限了&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">fp1</span> <span class="operator">=</span> Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getAbsolutePath();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">fc</span> <span class="operator">=</span> readSDCardFile(fp1+<span class="string">&quot;/b.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">Log.i(<span class="string">&quot;tttttttt&quot;</span>, <span class="string">&quot;文件内容：&quot;</span> + fc);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">Log.i(<span class="string">&quot;tttttttt&quot;</span>, <span class="string">&quot;还没有写SDCard的权限&quot;</span>);</span><br><span class="line"></span><br><span class="line">ActivityCompat.requestPermissions(MainActivity.<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, MY_PERMISSIONS_REQUEST_WRITE_CODE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRequestPermissionsResult</span><span class="params">(<span class="type">int</span> requestCode, <span class="meta">@NonNull</span> String[] permissions, <span class="meta">@NonNull</span> <span class="type">int</span>[] grantResults)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (requestCode)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MY_PERMISSIONS_REQUEST_WRITE_CODE:&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (grantResults.length &gt; <span class="number">0</span> &amp;&amp; grantResults[<span class="number">0</span>] != -<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">Log.i(<span class="string">&quot;tttttttt&quot;</span>, <span class="string">&quot;写SDCard权限申请成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">Log.i(<span class="string">&quot;tttttttt&quot;</span>, <span class="string">&quot;写SDCard权限申请失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">case</span> <span class="number">33</span>:&#123;</span><br><span class="line"></span><br><span class="line">Log.i(<span class="string">&quot;tttttttt&quot;</span>, <span class="string">&quot;这里是其他权限申请的结果&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* A native method that is implemented by the &#x27;ndk01&#x27; native library,</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* which is packaged with this application.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">stringFromJNI</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">readSDCardFile</span><span class="params">(String filePath)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cpp实现读取文件的功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGI(...) __android_log_print(ANDROID_LOG_INFO, <span class="string">&quot;tttttttt&quot;</span>, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, <span class="string">&quot;tttttttt&quot;</span>, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGW(...) __android_log_print(ANDROID_LOG_WARN, <span class="string">&quot;tttttttt&quot;</span>, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGE(...) __android_log_print(ANDROID_LOG_ERROR, <span class="string">&quot;tttttttt&quot;</span>, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> JNIEXPORT jstring JNICALL</span><br><span class="line"></span><br><span class="line"><span class="title function_">Java_a_b_c_ndk01_MainActivity_stringFromJNI</span><span class="params">(</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">JNIEnv* env,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">jobject <span class="comment">/* this */</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> hello = <span class="string">&quot;Hello from C++&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line"><span class="title function_">Java_a_b_c_ndk01_MainActivity_readSDCardFile</span><span class="params">(JNIEnv *env, jobject thiz, jstring file_path)</span> &#123;</span><br><span class="line">	<span class="comment">//先将java类型的字符串转换成c类型的字符</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* filePath = env-&gt;GetStringUTFChars(file_path, nullptr);</span><br><span class="line">    FILE *fp = fopen(filePath, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp == nullptr) &#123;</span><br><span class="line">    <span class="comment">//类似于android中的log.i就是打印日志的功能</span></span><br><span class="line">        LOGE(<span class="string">&quot;Failed to open file: %s&quot;</span>, filePath);</span><br><span class="line">        <span class="comment">//释放内存</span></span><br><span class="line">        env-&gt;ReleaseStringUTFChars(file_path, filePath);</span><br><span class="line">        <span class="keyword">return</span> env-&gt;NewStringUTF(<span class="string">&quot;open file failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> result;  <span class="comment">// 使用 std::string 拼接内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fgets(buffer, <span class="keyword">sizeof</span>(buffer), fp) != nullptr) &#123;</span><br><span class="line">        result += buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(file_path, filePath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(result.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="JNI方法"><a href="#JNI方法" class="headerlink" title="JNI方法"></a>JNI方法</h3><p>参考： <a target="_blank" rel="noopener" href="https://blog.csdn.net/afei__/article/details/81016413">https://blog.csdn.net/afei__/article/details/81016413</a></p>
<p>写一个例子,反射获取类和方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 告诉编译器使用 C 语言的函数命名方式，避免函数名被 C++ 编译器修改（名称改编）</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 JNI 函数，返回一个 jint（int 类型），对应 Java 中 native 方法：callJavaFunFromJNI</span></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line"><span class="title function_">Java_a_b_c_ndk01_MainActivity_callJavaFunFromJNI</span><span class="params">(JNIEnv *env, jobject thiz, jobject param)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 param 对象的类对象（即 Java 层传入的 Student 对象）</span></span><br><span class="line">    jclass jclass_student = env-&gt;GetObjectClass(param);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过类名查找 Student 类（可选，这里其实没用上）</span></span><br><span class="line">    jclass jclass_student2 = env-&gt;FindClass(<span class="string">&quot;a/b/c/ndk01/Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取名为 study 的成员方法 ID，签名表示接收一个 int，返回一个 String</span></span><br><span class="line">    jmethodID jmethodId_study = env-&gt;GetMethodID(jclass_student, <span class="string">&quot;study&quot;</span>, <span class="string">&quot;(I)Ljava/lang/String;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义参数传入 Java 的 study 方法</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">34</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 param 对象的 study 方法，返回一个 jobject（其实是 jstring 类型）</span></span><br><span class="line">    jobject jobject_ret = env-&gt;CallObjectMethod(param, jmethodId_study, flag);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将返回的 jstring 转换为 C 字符串</span></span><br><span class="line">    <span class="type">char</span>* t = (<span class="type">char</span>*)env-&gt;GetStringUTFChars((jstring)jobject_ret, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印 JNI 调用返回的字符串</span></span><br><span class="line">    LOGI(<span class="string">&quot;ndk call study ret: %s&quot;</span>, t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 flag 值（这里只是演示，实际返回值可以按需求设置）</span></span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续使用 C 语言命名规则</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 JNI 函数，返回 jstring（Java 字符串），对应 Java 中 native 方法：callStaticJavaFunFromJNI</span></span><br><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line"><span class="title function_">Java_a_b_c_ndk01_MainActivity_callStaticJavaFunFromJNI</span><span class="params">(JNIEnv *env, jobject thiz)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到 Student 类</span></span><br><span class="line">    jclass jclass_student2 = env-&gt;FindClass(<span class="string">&quot;a/b/c/ndk01/Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取名为 calcLength 的静态方法 ID，签名表示接收一个 String，返回一个 int</span></span><br><span class="line">    jmethodID jmethodId_calcLength = env-&gt;GetStaticMethodID(jclass_student2, <span class="string">&quot;calcLength&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)I&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 Java 字符串作为参数传入</span></span><br><span class="line">    jstring jstring_param = env-&gt;NewStringUTF(<span class="string">&quot;hahahaha&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用静态方法 calcLength，传入字符串参数，获取返回的 int 值</span></span><br><span class="line">    jint jint_ret = env-&gt;CallStaticIntMethod(jclass_student2, jmethodId_calcLength, jstring_param);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印返回的 int 值</span></span><br><span class="line">    LOGI(<span class="string">&quot;ndk call calcLength ret: %d&quot;</span>, jint_ret);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回原始字符串参数（只是为了展示）</span></span><br><span class="line">    <span class="keyword">return</span> jstring_param;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="JNI注册"><a href="#JNI注册" class="headerlink" title="JNI注册"></a>JNI注册</h3><h4 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h4><p>静态注册就是通过 JNIEXPORT 和 JNICALL 两个宏定义声明，在虚拟机加载 so 时发现上面两个宏定义的函数时就会链接到对应的 native 方法。</p>
<p>注册的规则：</p>
<p>Java + 包名 + 类名 + 方法名</p>
<p>其中使用下划线将每部分隔开，包名也使用下划线隔开，如果名称中本来就包含下划线，将使用下划线加数字替换。</p>
<p>示例 包名：<strong>com.afei.jnidemo</strong>，类名：<strong>MainActivity</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java native method</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">stringFromJNI</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// JNI method </span></span><br><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line"><span class="title function_">Java_com_afei_jnidemo_MainActivity_stringFromJNI</span><span class="params">( JNIEnv *env, jobject instance)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Java native method</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">stringFrom_JNI</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// JNI method </span></span><br><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line"><span class="title function_">Java_com_afei_jnidemo_MainActivity_stringFrom_1JNI</span><span class="params">(JNIEnv *env, jobject instance)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h4><p>通过 RegisterNatives 方法手动完成 native 方法和 so 中的方法的绑定，这样虚拟机就可以通过这个函数映射表直接找到相应的方法了。</p>
<p>来看一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">stringFromJNI</span><span class="params">()</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure>

<p>一般在JNI_OnLoad完成注册</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"> </span><br><span class="line">jstring <span class="title function_">stringFromJNI</span><span class="params">(JNIEnv *env, jobject instance)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> hello = <span class="string">&quot;Hello from C++&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">jint <span class="title function_">add</span><span class="params">(JNIEnv *env, jclass clazz, jint a, jint b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">jint <span class="title function_">RegisterNatives</span><span class="params">(JNIEnv *env)</span> &#123;</span><br><span class="line">    jclass clazz = env-&gt;FindClass(<span class="string">&quot;com/afei/jnidemo/MainActivity&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">&quot;con&#x27;t find class: com/afei/jnidemo/MainActivity&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    JNINativeMethod methods_MainActivity[] = &#123;</span><br><span class="line">            &#123;<span class="string">&quot;stringFromJNI&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, (<span class="type">void</span> *) stringFromJNI&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;add&quot;</span>,           <span class="string">&quot;(II)I&quot;</span>,                (<span class="type">void</span> *) add&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// int len = sizeof(methods_MainActivity) / sizeof(methods_MainActivity[0]);</span></span><br><span class="line">    <span class="keyword">return</span> env-&gt;RegisterNatives(clazz, methods_MainActivity,</span><br><span class="line">                                <span class="keyword">sizeof</span>(methods_MainActivity) / <span class="keyword">sizeof</span>(methods_MainActivity[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">jint <span class="title function_">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="type">void</span> *reserved)</span> &#123;<span class="comment">//这个方法是一个override方法，在加载动态库时，会自动调用，一般用来做一些初始化操作，动态注册的代码就可以写在这</span></span><br><span class="line">    JNIEnv *env = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (vm-&gt;GetEnv((<span class="type">void</span> **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123;<span class="comment">//首先需要获取JNIEnv *env指针，因为registerNativeMethod方法会用到</span></span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册本地方法（动态注册的关键一步）</span></span><br><span class="line">    jint result = RegisterNatives(env);</span><br><span class="line">    LOGD(<span class="string">&quot;RegisterNatives result: %d&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="RegisterNatives方法解析"><a href="#RegisterNatives方法解析" class="headerlink" title="RegisterNatives方法解析"></a>RegisterNatives方法解析</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">定义： jint RegisterNatives(jclass clazz, const JNINativeMethod* methods, jint nMethods)</span><br><span class="line"></span><br><span class="line">clazz：指定的类，即 native 方法所属的类</span><br><span class="line">methods：方法数组，这里需要了解一下 JNINativeMethod 结构体</span><br><span class="line">nMethods：方法数组的长度</span><br></pre></td></tr></table></figure>

<p><strong>JNINativeMethod</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name; <span class="comment">// native 的方法名</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* signature; <span class="comment">// 方法签名，例如 ()Ljava/lang/String;</span></span><br><span class="line">    <span class="type">void</span>*       fnPtr; <span class="comment">// 函数指针</span></span><br><span class="line">&#125; JNINativeMethod;</span><br></pre></td></tr></table></figure>

<h3 id="Android-mk-和-CMake-语法"><a href="#Android-mk-和-CMake-语法" class="headerlink" title="Android.mk 和 CMake 语法"></a>Android.mk 和 CMake 语法</h3><p>参考：<br> <a target="_blank" rel="noopener" href="https://blog.csdn.net/afei__/article/details/84069876">Android.mk 语法和变量介绍</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/afei__/article/details/81201039">CMakeLists.txt 语法介绍与实例演练</a></p>
<h3 id="Android-Studio-中使用-NDK"><a href="#Android-Studio-中使用-NDK" class="headerlink" title="Android Studio 中使用 NDK"></a>Android Studio 中使用 NDK</h3><p>   <a target="_blank" rel="noopener" href="https://blog.csdn.net/afei__/article/details/81271594">gradle 配置 cmake，及各参数详解</a></p>
<p>   <a target="_blank" rel="noopener" href="https://blog.csdn.net/afei__/article/details/81272251">gardle 配置 ndk 指定 ABI： abiFilters 详解</a></p>
<h2 id="APK文件结构"><a href="#APK文件结构" class="headerlink" title="APK文件结构"></a>APK文件结构</h2><p>参考： <a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-278112.htm">https://bbs.kanxue.com/thread-278112.htm</a></p>
<h3 id="assets文件夹"><a href="#assets文件夹" class="headerlink" title="assets文件夹"></a>assets文件夹</h3><p>assets 这里存放的是静态资源文件(图片，视频等)，这个文件夹下的资源文件不会被编译。不被编译的资源文件是指在编译过程中不会被转换成二进制代码的文件，而是直接被打包到最终的程序中。这些文件通常是一些静态资源，如图片、音频、文本文件等。</p>
<h3 id="lib文件夹"><a href="#lib文件夹" class="headerlink" title="lib文件夹"></a>lib文件夹</h3><p>lib：.so库(c或c++编译的动态链接库)。APK文件中的动态链接库（Dynamic Link Library，简称DLL）是一种可重用的代码库，它包含在应用程序中，以便在运行时被调用。这些库通常包含许多常见的函数和程序，可以在多个应用程序中共享，从而提高了代码的复用性和效率。</p>
<p>lib文件夹下的每个目录都适用于不同的环境下，armeabi-v7a目录基本通用所有android设备，arm64-v8a目录只适用于64位的android设备，x86目录常见用于android模拟器，x86-64目录适用于支持x86_64架构的Android设备(适用于支持通常称为“x86-64”的指令集的 CPU)</p>
<h3 id="META-INF文件夹"><a href="#META-INF文件夹" class="headerlink" title="META-INF文件夹"></a>META-INF文件夹</h3><p>META-INF：在Android应用的APK文件中，META-INF文件夹是存放数字签名相关文件的文件夹，包含以下三个文件：</p>
<ol>
<li>MANIFEST.MF：MANIFEST.MF 是一个摘要清单文件，它包含了 APK 文件中除自身外所有文件的数字摘要。这些摘要通常是通过特定的哈希算法（如 SHA - 1、SHA - 256 等）对文件内容进行计算得到的，用于确保文件内容在传输或存储过程中未被篡改。</li>
<li>CERT.SF：CERT.SF 文件存储了 MANIFEST.MF 文件的数字摘要以及 MANIFEST.MF 中每个文件条目的数字摘要的二次摘要。开发者使用自己的私钥对 CERT.SF 进行签名，以保证 CERT.SF 文件内容的完整性和真实性。</li>
<li>CERT.RSA：CERT.RSA 文件包含了使用开发者私钥对 CERT.SF 文件进行签名得到的数字签名以及签名时所使用的数字证书。当验证 APK 的签名时，系统会使用数字证书中的公钥来验证 CERT.SF 文件的数字签名是否有效，从而确保 CERT.SF 文件未被篡改，进而验证 MANIFEST.MF 文件和整个 APK 的完整性。</li>
</ol>
<h3 id="AndroidManifest-xml配置文件"><a href="#AndroidManifest-xml配置文件" class="headerlink" title="AndroidManifest.xml配置文件"></a>AndroidManifest.xml配置文件</h3><p>AndroidManifest.xml是Android应用程序中最重要的文件之一，它包含了应用程序的基本信息，如应用程序的名称、图标、版本号、权限、组件（Activity、Service、BroadcastReceiver、Content Provider）等等。在应用程序运行时，系统会根据这个文件来管理应用程序的生命周期，启动和关闭应用程序，管理应用程序的组件等等。</p>
<p>我们来了解一下AndroidManifest.xml文件的主要组成部分：</p>
<ol>
<li>manifest标签</li>
</ol>
<p>manifest标签是AndroidManifest.xml文件的根标签，它包含了应用程序的基本信息，如包名、版本号、SDK版本、应用程序的名称和图标等等。</p>
<ol>
<li>application标签</li>
</ol>
<p>application标签是应用程序的主要标签，它包含了应用程序的所有组件，如Activity(活动)、Service(服务)、Broadcast Receiver(广播接收器)、Content Provider(内容提供者)等等。在application标签中，也可以设置应用程序的全局属性，如主题、权限等等。</p>
<ol>
<li>activity标签</li>
</ol>
<p>activity标签定义了一个Activity组件，它包含了Activity的基本信息，如Activity的名称、图标、主题、启动模式等等。在activity标签中，还可以定义Activity的布局、Intent过滤器等等。</p>
<ol>
<li>service标签</li>
</ol>
<p>service标签定义了一个Service组件，它包含了Service的基本信息，如Service的名称、图标、启动模式等等。在service标签中，还可以定义Service的Intent过滤器等等。</p>
<ol>
<li>receiver标签</li>
</ol>
<p>receiver标签定义了一个BroadcastReceiver组件，它包含了BroadcastReceiver的基本信息，如BroadcastReceiver的名称、图标、权限等等。在receiver标签中，还可以定义BroadcastReceiver的Intent过滤器等等。</p>
<ol>
<li>provider标签</li>
</ol>
<p>provider标签定义了一个Content Provider组件，它包含了Content Provider的基本信息，如Content Provider的名称、图标、权限等等。在provider标签中，还可以定义Content Provider的URI和Mime Type等等。</p>
<ol>
<li>uses-permission标签</li>
</ol>
<p>uses-permission标签定义了应用程序需要的权限，如访问网络、读取SD卡等等。在应用程序安装时，系统会提示用户授权这些权限。</p>
<ol>
<li>uses-feature标签</li>
</ol>
<p>uses-feature标签定义了应用程序需要的硬件或软件特性，如摄像头、GPS等等。在应用程序安装时，系统会检查设备是否支持这些特性。</p>
<p>以上是AndroidManifest.xml文件的主要组成部分，它们共同定义了应用程序的基本信息和组件，是应用程序的重要配置文件。现在如果看起来有点懵，没关系，后面实战会使用到它的，以后也会对它进行详解，那时你或许会有一点对它的理解了。</p>
<h3 id="resources-arsc文件"><a href="#resources-arsc文件" class="headerlink" title="resources.arsc文件"></a>resources.arsc文件</h3><p>resources.arsc文件是Android应用程序的资源文件之一，它是一个二进制文件，包含了应用程序的所有资源信息，例如布局文件、字符串、图片等。这个文件在应用程序编译过程中由aapt工具生成，并被打包进APK文件中。</p>
<p>resources.arsc文件的主要作用是提供资源的索引和映射关系。它将资源文件名、类型、值等信息映射到一个唯一的整数ID上。这个ID在R文件中定义，并且可以通过代码中的R类来引用。例如，R.layout.main表示布局文件main.xml对应的ID，R.string.app_name表示字符串资源app_name对应的ID。</p>
<p>当应用程序运行时，系统会根据R类中的ID来查找对应的资源，并将其加载到内存中，供应用程序使用。这个过程是通过解析resources.arsc文件和R类实现的。通过这种方式，应用程序可以方便地访问和使用资源，而不需要手动处理资源文件的位置和命名等问题。</p>
<p>需要注意的是，resources.arsc文件只包含资源的索引和映射关系，并不包含实际的资源内容。实际的资源内容存储在res文件夹中，按照资源类型和名称进行组织。当应用程序需要使用资源时，系统会根据resources.arsc文件中的索引信息找到对应的资源文件，并将其加载到内存中。</p>
<p>总之，resources.arsc文件是Android应用程序的资源文件之一，包含了资源的索引和映射关系。它和R类一起构成了应用程序访问和使用资源的基础。通过解析resources.arsc文件和使用R类，应用程序可以方便地加载和使用资源。</p>
<p>参考其他的文章<br><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/elink@9e3K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6B7N6h3g2B7K9h3&6Q4x3X3g2U0L8W2)9J5c8Y4m8G2M7%4c8Q4x3V1j5$3z5e0R3$3y4o6b7%5E5x3K6f1#2z5e0j5J5y4o6l9@1z5o6M7%4">Android资源管理及资源的编译和打包过程分析 - 掘金 (juejin.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/elink@16dK9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6T1L8r3!0Y4i4K6u0W2j5%4y4V1L8W2)9J5k6h3&6W2N6q4)9J5c8X3u0W2P5h3!0F1k6o6M7H3x3W2)9J5c8X3q4J5N6r3W2U0L8r3g2Q4x3V1k6V1k6i4c8S2K9h3I4K6i4K6u0r3y4e0p5%4y4o6b7H3z5o6t1%60.">(32条消息) 手把手教你解析Resources.arsc_beyond702的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/elink@812K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6B7N6h3g2B7K9h3&6Q4x3X3g2U0L8W2)9J5c8Y4m8G2M7%4c8Q4x3V1j5%4x3o6M7J5z5o6V1%4x3K6t1%4y4e0l9&6x3U0M7@1y4U0x3I4i4K6t1K6K9r3g2S2k6r3W2F1k6#2)9J5k6o6M7%60.">Android逆向：resource.arsc文件解析（Config List） - 掘金 (juejin.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/elink@69dK9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6T1L8r3!0Y4i4K6u0W2j5%4y4V1L8W2)9J5k6h3&6W2N6q4)9J5c8X3y4Z5P5Y4m8Z5L8$3g2F1K9i4S2Q4x3V1k6S2M7Y4c8A6j5$3I4W2i4K6u0r3k6r3g2@1j5h3W2D9M7#2)9J5c8U0R3H3y4e0j5&6y4e0j5%4">(32条消息) resource.arsc二进制内容解析 之 Dynamic package reference_BennuCTech的博客-CSDN博客</a></p>
<h3 id="res文件夹"><a href="#res文件夹" class="headerlink" title="res文件夹"></a>res文件夹</h3><p>res：资源文件目录，二进制格式。实际上，APK文件下的res文件夹并不是二进制格式，而是经过编译后的二进制资源文件。在Android应用程序开发中，资源文件通常是以XML格式存储的，如布局文件、字符串资源、颜色资源等。在编译时，Android编译器会将这些XML资源文件编译成二进制格式的资源文件，以提高应用程序的运行效率和安全性。虽然res文件夹下的二进制资源文件不能直接编辑和修改，但是开发者仍然可以通过Android提供的资源管理工具，如aapt、apktool等，来反编译和编辑这些资源文件的。</p>
<p>在res文件夹中，主要包含以下子文件夹和文件：</p>
<table>
<thead>
<tr>
<th>res子目录</th>
<th>存储的资源类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>animator/</code></td>
<td>用于定义<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/elink@5b6K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6V1k6i4k6W2L8r3!0H3k6i4u0Q4x3X3g2S2L8X3c8J5L8$3W2V1i4K6u0W2k6$3!0G2k6$3I4W2i4K6u0W2j5$3&6Q4x3V1k6Y4N6h3W2V1k6g2)9J5c8Y4c8G2M7r3W2U0M7#2)9J5c8X3N6J5j5i4m8Z5K9h3y4K6i4K6u0r3M7s2u0G2M7q4)9J5k6r3q4F1K9h3#2S2N6r3W2G2L8W2)9K6c8X3S2D9i4K6y4p5P5X3S2Q4x3X3c8U0L8R3%60.%60.">属性动画</a>的 XML 文件。</td>
</tr>
<tr>
<td><code>anim/</code></td>
<td>用于定义<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/elink@907K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6V1k6i4k6W2L8r3!0H3k6i4u0Q4x3X3g2S2L8X3c8J5L8$3W2V1i4K6u0W2k6$3!0G2k6$3I4W2i4K6u0W2j5$3&6Q4x3V1k6Y4N6h3W2V1k6g2)9J5c8Y4c8G2M7r3W2U0M7#2)9J5c8X3N6J5j5i4m8Z5K9h3y4K6i4K6u0r3N6X3W2W2N6#2)9J5k6r3q4F1K9h3#2S2N6r3W2G2L8W2)9K6c8X3S2D9i4K6y4p5P5X3S2Q4x3X3c8U0L8W2)9J5x3%4c8%4k6h3g2F1i4K6u0V1j5h3&6A6L8h3q4@1K9h3!0F1">补间动画</a>的 XML 文件。属性动画也可保存在此目录中，但为了区分这两种类型，属性动画首选 <code>animator/</code> 目录。</td>
</tr>
<tr>
<td><code>color/</code></td>
<td>定义颜色状态列表的 XML 文件。如需了解详情，请参阅<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/elink@6c3K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6V1k6i4k6W2L8r3!0H3k6i4u0Q4x3X3g2S2L8X3c8J5L8$3W2V1i4K6u0W2k6$3!0G2k6$3I4W2i4K6u0W2j5$3&6Q4x3V1k6Y4N6h3W2V1k6g2)9J5c8Y4c8G2M7r3W2U0M7#2)9J5c8Y4u0W2M7$3!0#2M7X3y4W2M7#2)9J5c8X3y4G2L8r3!0J5i4K6u0V1L8r3W2K6N6q4)9J5k6s2u0W2M7$3!0#2M7X3y4W2i4K6y4r3K9r3I4Q4x3@1c8*7K9q4)9J5k6r3y4F1">颜色状态列表资源</a>。</td>
</tr>
<tr>
<td><code>drawable/</code></td>
<td>位图文件（PNG、<code>.9.png</code>、JPG 或 GIF）或编译为以下可绘制资源子类型的 XML 文件：位图文件九宫图（可调整大小的位图）状态列表形状动画可绘制对象其他可绘制对象如需了解详情，请参阅<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/elink@225K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6V1k6i4k6W2L8r3!0H3k6i4u0Q4x3X3g2S2L8X3c8J5L8$3W2V1i4K6u0W2k6$3!0G2k6$3I4W2i4K6u0W2j5$3&6Q4x3V1k6Y4N6h3W2V1k6g2)9J5c8Y4c8G2M7r3W2U0M7#2)9J5c8Y4u0W2M7$3!0#2M7X3y4W2M7#2)9J5c8X3c8J5j5i4N6S2j5X3I4W2i4K6u0V1M7X3g2K6L8%4g2J5j5$3g2Q4x3@1k6Z5L8q4)9K6c8s2A6Z5i4K6u0V1j5$3^5%60.">可绘制资源</a>。</td>
</tr>
<tr>
<td><code>mipmap/</code></td>
<td>适用于不同启动器图标密度的可绘制对象文件。如需详细了解如何使用 <code>mipmap/</code> 文件夹管理启动器图标，请参阅<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/elink@bfcK9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6V1k6i4k6W2L8r3!0H3k6i4u0Q4x3X3g2S2L8X3c8J5L8$3W2V1i4K6u0W2k6$3!0G2k6$3I4W2i4K6u0W2j5$3&6Q4x3V1k6@1M7X3q4A6L8X3W2F1k6#2)9J5c8X3#2#2L8s2c8A6M7$3y4J5k6h3g2F1i4K6u0r3M7$3y4J5k6h3g2F1k6r3g2F1M7$3W2@1K9h3g2K6i4K6y4r3K9r3I4Q4x3@1c8*7K9q4)9J5k6r3y4F1i4K6t1K6L8h3W2H3L8h3q4H3">将应用图标放在 mipmap 目录中</a>。</td>
</tr>
<tr>
<td><code>layout/</code></td>
<td>用于定义界面布局的 XML 文件。如需了解详情，请参阅<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/elink@55eK9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6V1k6i4k6W2L8r3!0H3k6i4u0Q4x3X3g2S2L8X3c8J5L8$3W2V1i4K6u0W2k6$3!0G2k6$3I4W2i4K6u0W2j5$3&6Q4x3V1k6Y4N6h3W2V1k6g2)9J5c8Y4c8G2M7r3W2U0M7#2)9J5c8Y4u0W2M7$3!0#2M7X3y4W2M7#2)9J5c8X3I4S2P5h3!0#2N6q4)9J5k6s2u0W2M7$3!0#2M7X3y4W2i4K6y4r3K9r3I4Q4x3@1c8*7K9q4)9J5k6r3y4F1">布局资源</a>。</td>
</tr>
<tr>
<td><code>menu/</code></td>
<td>用于定义应用菜单（例如选项菜单、上下文菜单或子菜单）的 XML 文件。如需了解详情，请参阅<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/elink@3beK9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6V1k6i4k6W2L8r3!0H3k6i4u0Q4x3X3g2S2L8X3c8J5L8$3W2V1i4K6u0W2k6$3!0G2k6$3I4W2i4K6u0W2j5$3&6Q4x3V1k6Y4N6h3W2V1k6g2)9J5c8Y4c8G2M7r3W2U0M7#2)9J5c8Y4u0W2M7$3!0#2M7X3y4W2M7#2)9J5c8X3#2W2L8Y4g2Q4x3X3c8J5k6i4y4G2N6i4u0U0k6g2)9K6c8X3S2D9i4K6y4p5P5X3S2Q4x3X3c8U0L8R3%60.%60.">菜单资源</a>。</td>
</tr>
<tr>
<td><code>raw/</code></td>
<td>需以原始形式保存的任意文件。如要使用原始 <code>InputStream</code> 打开这些资源，请使用资源 ID（即 <code>R.raw.*filename*</code>）调用 <code>Resources.openRawResource()</code>。但是，如需访问原始文件名和文件层次结构，请考虑将资源保存在 <code>assets/</code> 目录（而非 <code>res/raw/</code>）下。<code>assets/</code> 中的文件没有资源 ID，因此您只能使用 <code>AssetManager</code> 读取这些文件。</td>
</tr>
<tr>
<td><code>values/</code></td>
<td>包含字符串、整数和颜色等简单值的 XML 文件。其他 <code>res/</code> 子目录中的 XML 资源文件会根据 XML 文件名定义单个资源，而 <code>values/</code> 目录中的文件可描述多个资源。对于此目录中的文件，<code>&lt;resources&gt;</code> 元素的每个子元素均会定义一个资源。例如，<code>&lt;string&gt;</code> 元素会创建 <code>R.string</code> 资源，<code>&lt;color&gt;</code> 元素会创建 <code>R.color</code> 资源。由于每个资源均使用自己的 XML 元素进行定义，因此您可以随意命名文件，并在某个文件中放入不同的资源类型。但是，您可能需要将独特的资源类型放在不同的文件中，使其一目了然。例如，对于可在此目录中创建的资源，下面给出了相应的文件名约定：<code>arrays.xml</code> 用于资源数组（<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/elink@630K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6V1k6i4k6W2L8r3!0H3k6i4u0Q4x3X3g2S2L8X3c8J5L8$3W2V1i4K6u0W2k6$3!0G2k6$3I4W2i4K6u0W2j5$3&6Q4x3V1k6Y4N6h3W2V1k6g2)9J5c8Y4c8G2M7r3W2U0M7#2)9J5c8Y4u0W2M7$3!0#2M7X3y4W2M7#2)9J5c8X3#2G2M7X3g2Q4x3X3c8J5k6i4y4G2N6i4u0U0k6i4y4Q4x3@1k6Z5L8q4)9K6c8s2A6Z5i4K6u0V1j5$3&6Q4x3U0y4f1P5i4m8W2k6p5q4J5M7X3q4&6">类型化数组</a>）<code>colors.xml</code> 用于<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/elink@945K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6V1k6i4k6W2L8r3!0H3k6i4u0Q4x3X3g2S2L8X3c8J5L8$3W2V1i4K6u0W2k6$3!0G2k6$3I4W2i4K6u0W2j5$3&6Q4x3V1k6Y4N6h3W2V1k6g2)9J5c8Y4c8G2M7r3W2U0M7#2)9J5c8Y4u0W2M7$3!0#2M7X3y4W2M7#2)9J5c8X3#2G2M7X3g2Q4x3X3c8J5k6i4y4G2N6i4u0U0k6i4y4Q4x3@1k6Z5L8q4)9K6c8s2A6Z5i4K6u0V1j5$3&6Q4x3U0y4o6L8$3I4G2M7R3%60.%60.">颜色值</a><code>dimens.xml</code> 用于<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/elink@822K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6V1k6i4k6W2L8r3!0H3k6i4u0Q4x3X3g2S2L8X3c8J5L8$3W2V1i4K6u0W2k6$3!0G2k6$3I4W2i4K6u0W2j5$3&6Q4x3V1k6Y4N6h3W2V1k6g2)9J5c8Y4c8G2M7r3W2U0M7#2)9J5c8Y4u0W2M7$3!0#2M7X3y4W2M7#2)9J5c8X3#2G2M7X3g2Q4x3X3c8J5k6i4y4G2N6i4u0U0k6i4y4Q4x3@1k6Z5L8q4)9K6c8s2A6Z5i4K6u0V1j5$3&6Q4x3U0y4p5K9h3#2W2L8Y4y4A6L8$3^5%60.">维度值</a><code>strings.xml</code> 用于<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/elink@eb4K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6V1k6i4k6W2L8r3!0H3k6i4u0Q4x3X3g2S2L8X3c8J5L8$3W2V1i4K6u0W2k6$3!0G2k6$3I4W2i4K6u0W2j5$3&6Q4x3V1k6Y4N6h3W2V1k6g2)9J5c8Y4c8G2M7r3W2U0M7#2)9J5c8Y4u0W2M7$3!0#2M7X3y4W2M7#2)9J5c8Y4y4@1M7X3W2F1k6#2)9J5k6s2u0W2M7$3!0#2M7X3y4W2i4K6y4r3K9r3I4Q4x3@1c8*7K9q4)9J5k6r3y4F1">字符串值</a><code>styles.xml</code> 用于<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/elink@fedK9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6V1k6i4k6W2L8r3!0H3k6i4u0Q4x3X3g2S2L8X3c8J5L8$3W2V1i4K6u0W2k6$3!0G2k6$3I4W2i4K6u0W2j5$3&6Q4x3V1k6Y4N6h3W2V1k6g2)9J5c8Y4c8G2M7r3W2U0M7#2)9J5c8Y4u0W2M7$3!0#2M7X3y4W2M7#2)9J5c8Y4y4@1P5h3I4W2i4K6u0V1M7X3g2K6L8%4g2J5j5$3g2Q4x3@1k6Z5L8q4)9K6c8s2A6Z5i4K6u0V1j5$3^5%60.">样式</a>如需了解详情，请参阅<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/elink@971K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6V1k6i4k6W2L8r3!0H3k6i4u0Q4x3X3g2S2L8X3c8J5L8$3W2V1i4K6u0W2k6$3!0G2k6$3I4W2i4K6u0W2j5$3&6Q4x3V1k6Y4N6h3W2V1k6g2)9J5c8Y4c8G2M7r3W2U0M7#2)9J5c8Y4u0W2M7$3!0#2M7X3y4W2M7#2)9J5c8Y4y4@1M7X3W2F1k6#2)9J5k6s2u0W2M7$3!0#2M7X3y4W2i4K6y4r3K9r3I4Q4x3@1c8*7K9q4)9J5k6r3y4F1">字符串资源</a>、<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/elink@3cbK9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6V1k6i4k6W2L8r3!0H3k6i4u0Q4x3X3g2S2L8X3c8J5L8$3W2V1i4K6u0W2k6$3!0G2k6$3I4W2i4K6u0W2j5$3&6Q4x3V1k6Y4N6h3W2V1k6g2)9J5c8Y4c8G2M7r3W2U0M7#2)9J5c8Y4u0W2M7$3!0#2M7X3y4W2M7#2)9J5c8Y4y4@1P5h3I4W2i4K6u0V1M7X3g2K6L8%4g2J5j5$3g2Q4x3@1k6Z5L8q4)9K6c8s2A6Z5i4K6u0V1j5$3^5%60.">样式资源</a>和<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/elink@f35K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6V1k6i4k6W2L8r3!0H3k6i4u0Q4x3X3g2S2L8X3c8J5L8$3W2V1i4K6u0W2k6$3!0G2k6$3I4W2i4K6u0W2j5$3&6Q4x3V1k6Y4N6h3W2V1k6g2)9J5c8Y4c8G2M7r3W2U0M7#2)9J5c8Y4u0W2M7$3!0#2M7X3y4W2M7#2)9J5c8X3#2G2M7X3g2Q4x3X3c8J5k6i4y4G2N6i4u0U0k6i4y4Q4x3@1k6Z5L8q4)9K6c8s2A6Z5i4K6u0V1j5$3^5%60.">更多资源类型</a>。</td>
</tr>
<tr>
<td><code>xml/</code></td>
<td>可在运行时通过调用 <code>Resources.getXML()</code> 读取的任意 XML 文件。各种 XML 配置文件（例如<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/elink@4dfK9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6V1k6i4k6W2L8r3!0H3k6i4u0Q4x3X3g2S2L8X3c8J5L8$3W2V1i4K6u0W2k6$3!0G2k6$3I4W2i4K6u0W2j5$3&6Q4x3V1k6Y4N6h3W2V1k6g2)9J5c8Y4c8G2M7r3W2U0M7#2)9J5c8Y4y4W2j5i4u0U0K9q4)9J5c8Y4y4W2j5i4u0U0K9r3q4T1L8r3g2Q4x3X3c8U0L8$3&6X3K9h3N6Q4x3@1k6Z5L8q4)9K6c8s2A6Z5i4K6u0V1j5$3^5%60.">搜索配置</a>）都必须保存在此处。</td>
</tr>
<tr>
<td><code>font/</code></td>
<td>带有扩展名的字体文件（例如 TTF、OTF 或 TTC），或包含 <code>&lt;font-family&gt;</code> 元素的 XML 文件。如需详细了解以资源形式使用的字体，请参阅<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/elink@a79K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6V1k6i4k6W2L8r3!0H3k6i4u0Q4x3X3g2S2L8X3c8J5L8$3W2V1i4K6u0W2k6$3!0G2k6$3I4W2i4K6u0W2j5$3&6Q4x3V1k6Y4N6h3W2V1k6g2)9J5c8Y4c8G2M7r3W2U0M7#2)9J5c8Y4g2A6i4K6u0r3L8r3!0G2K9#2)9J5k6r3q4F1k6q4)9J5k6r3k6W2k6h3I4Q4x3V1k6X3L8$3&6@1M7#2)9J5k6r3W2F1i4K6u0V1P5r3#2D9i4K6y4r3K9r3I4Q4x3@1c8*7K9q4)9J5k6r3y4F1">将字体添加为 XML 资源</a>。</td>
</tr>
</tbody></table>
<h2 id="dex文件结构"><a href="#dex文件结构" class="headerlink" title="dex文件结构"></a>dex文件结构</h2><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1663852">https://cloud.tencent.com/developer/article/1663852</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903847647772686">https://juejin.cn/post/6844903847647772686</a></p>
<p>如何将编译dex文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./d8 --debug  --output dex输出路径 class文件</span><br></pre></td></tr></table></figure>

<img src="/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250412173543134.png" class="">

<p>再来一个简洁的图</p>
<img src="/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250412173630147.png" class="">
<ul>
<li><code>header :</code> DEX 文件头，记录了一些当前文件的信息以及其他数据结构在文件中的偏移量</li>
<li><code>string_ids :</code> 字符串的偏移量</li>
<li><code>type_ids :</code> 类型信息的偏移量</li>
<li><code>proto_ids :</code> 方法声明的偏移量</li>
<li><code>field_ids :</code> 字段信息的偏移量</li>
<li><code>method_ids :</code> 方法信息（所在类，方法声明以及方法名）的偏移量</li>
<li><code>class_def :</code> 类信息的偏移量</li>
<li><code>data :</code> ： 数据区</li>
<li><code>link_data :</code> 静态链接数据区</li>
</ul>
<p>从 <code>header</code> 到 <code>data</code> 之间都是偏移量数组，并不存储真实数据，所有数据都存在 <code>data</code> 数据区，根据其偏移量区查找。对 DEX 文件有了一个大概的认识之后，我们就来详细分析一下各个部分。</p>
<p>DEX 文件头部分的具体格式可以参考 DexFile.h 中的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexHeader</span> &#123;</span></span><br><span class="line">    u1  magic[<span class="number">8</span>];           <span class="comment">// 魔数</span></span><br><span class="line">    u4  checksum;           <span class="comment">// adler 校验值</span></span><br><span class="line">    u1  signature[kSHA1DigestLen]; <span class="comment">// sha1 校验值</span></span><br><span class="line">    u4  fileSize;           <span class="comment">// DEX 文件大小</span></span><br><span class="line">    u4  headerSize;         <span class="comment">// DEX 文件头大小</span></span><br><span class="line">    u4  endianTag;          <span class="comment">// 字节序</span></span><br><span class="line">    u4  linkSize;           <span class="comment">// 链接段大小</span></span><br><span class="line">    u4  linkOff;            <span class="comment">// 链接段的偏移量</span></span><br><span class="line">    u4  mapOff;             <span class="comment">// DexMapList 偏移量</span></span><br><span class="line">    u4  stringIdsSize;      <span class="comment">// DexStringId 个数</span></span><br><span class="line">    u4  stringIdsOff;       <span class="comment">// DexStringId 偏移量</span></span><br><span class="line">    u4  typeIdsSize;        <span class="comment">// DexTypeId 个数</span></span><br><span class="line">    u4  typeIdsOff;         <span class="comment">// DexTypeId 偏移量</span></span><br><span class="line">    u4  protoIdsSize;       <span class="comment">// DexProtoId 个数</span></span><br><span class="line">    u4  protoIdsOff;        <span class="comment">// DexProtoId 偏移量</span></span><br><span class="line">    u4  fieldIdsSize;       <span class="comment">// DexFieldId 个数</span></span><br><span class="line">    u4  fieldIdsOff;        <span class="comment">// DexFieldId 偏移量</span></span><br><span class="line">    u4  methodIdsSize;      <span class="comment">// DexMethodId 个数</span></span><br><span class="line">    u4  methodIdsOff;       <span class="comment">// DexMethodId 偏移量</span></span><br><span class="line">    u4  classDefsSize;      <span class="comment">// DexCLassDef 个数</span></span><br><span class="line">    u4  classDefsOff;       <span class="comment">// DexClassDef 偏移量</span></span><br><span class="line">    u4  dataSize;           <span class="comment">// 数据段大小</span></span><br><span class="line">    u4  dataOff;            <span class="comment">// 数据段偏移量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>magic</code> 一般是常量，用来标记 DEX 文件，它可以分解为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件标识 dex + 换行符 + DEX 版本 + 0</span><br></pre></td></tr></table></figure>

<p>字符串格式为 <code>dex\n035\0</code>，十六进制为 <code>0x6465780A30333500</code>。</p>
<p><code>checksum</code> 是对去除 <code>magic</code> 、 <code>checksum</code> 以外的文件部分作 alder32 算法得到的校验值，用于判断 DEX 文件是否被篡改。</p>
<p><code>signature</code> 是对除去 <code>magic</code> 、 <code>checksum</code> 、 <code>signature</code> 以外的文件部分作 sha1 得到的文件哈希值。</p>
<p><code>endianTag</code> 用于标记 DEX 文件是大端表示还是小端表示。由于 DEX 文件是运行在 Android 系统中的，所以一般都是小端表示，这个值也是恒定值 <code>0x12345678</code>。</p>
<h3 id="string-ids"><a href="#string-ids" class="headerlink" title="string_ids"></a>string_ids</h3><p> <code>string_ids</code> 是一个表，保存了 <strong>所有字符串的引用地址</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexStringId</span> &#123;</span></span><br><span class="line">    u4 stringDataOff;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>先来写一个工具类后面的也都用这个工具类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从字节数组中读取 4 字节 little-endian 整数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">readInt</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((data[offset] &amp; <span class="number">0xFF</span>)) |</span><br><span class="line">           ((data[offset + <span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">           ((data[offset + <span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">           ((data[offset + <span class="number">3</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从指定 offset 位置开始读取一个 ULEB128 编码的整数</span></span><br><span class="line"><span class="comment">// 返回值：[整数值，占用字节数]</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] readUleb128(<span class="type">byte</span>[] data, <span class="type">int</span> offset) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;     <span class="comment">// 解析结果</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;      <span class="comment">// ULEB128 占用的字节数</span></span><br><span class="line">    <span class="type">int</span> cur;</span><br><span class="line">    <span class="type">int</span> <span class="variable">shift</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        cur = data[offset + count] &amp; <span class="number">0xFF</span>;         <span class="comment">// 当前字节</span></span><br><span class="line">        result |= (cur &amp; <span class="number">0x7F</span>) &lt;&lt; shift;           <span class="comment">// 去掉最高位后累加到结果</span></span><br><span class="line">        shift += <span class="number">7</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((cur &amp; <span class="number">0x80</span>) != <span class="number">0</span>); <span class="comment">// 如果最高位为1，继续读下一个字节</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;result, count&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 offset 开始读取 UTF-8 编码的字符串，直到遇到 \0 结束</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">readString</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> offset;</span><br><span class="line">    <span class="keyword">while</span> (data[end] != <span class="number">0</span>) end++; <span class="comment">// 找到 null terminator</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(data, offset, end - offset, StandardCharsets.UTF_8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析 DEX 文件中的 string_ids 表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseStringIds</span><span class="params">(<span class="type">byte</span>[] dexData)</span> &#123;</span><br><span class="line">    <span class="comment">// 从 DEX 文件头偏移 0x38 读取 string_ids_size（字符串数量）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">stringIdsSize</span> <span class="operator">=</span> readInt(dexData, <span class="number">0x38</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从偏移 0x3C 读取 string_ids_off（string_id 表的起始位置）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">stringIdsOff</span> <span class="operator">=</span> readInt(dexData, <span class="number">0x3C</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Total strings: &quot;</span> + stringIdsSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有 string_id_item</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringIdsSize; i++) &#123;</span><br><span class="line">        <span class="comment">// 每个 string_id 占 4 字节，表示 string_data_item 的偏移地址</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">stringDataOff</span> <span class="operator">=</span> readInt(dexData, stringIdsOff + i * <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取 ULEB128 编码的字符串长度（字符数量，不是字节数），并获得该编码占用的字节数</span></span><br><span class="line">        <span class="type">int</span>[] result = readUleb128(dexData, stringDataOff);</span><br><span class="line">        <span class="type">int</span> <span class="variable">utf16Size</span> <span class="operator">=</span> result[<span class="number">0</span>];         <span class="comment">// 实际字符数（通常你可以忽略它）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">stringOffset</span> <span class="operator">=</span> stringDataOff + result[<span class="number">1</span>]; <span class="comment">// 字符串真实内容的起始位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 offset 开始读取 UTF-8 编码的字符串内容（直到遇到 0x00 为止）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> readString(dexData, stringOffset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出解析到的字符串</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;string[%d] = %s\n&quot;</span>, i, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="type-ids"><a href="#type-ids" class="headerlink" title="type_ids"></a>type_ids</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexTypeId</span> &#123;</span></span><br><span class="line">    u4  descriptorIdx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>type_ids</code> 表示的是类型信息，<code>descriptorIdx</code> 指向 <code>string_ids</code> 中元素。根据索引直接在上一步读取到的字符串池即可解析对应的类型信息，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">typeIdsSize</span> <span class="operator">=</span> Utils.readInt(dexData, <span class="number">0x40</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">typeIdsOff</span> <span class="operator">=</span> Utils.readInt(dexData, <span class="number">0x44</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; typeIdsSize; i++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">stringIndex</span> <span class="operator">=</span> Utils.readInt(dexData, typeIdsOff + i * <span class="number">4</span>); <span class="comment">// 获取 type_id 对应的 string_ids 索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来就是去 string_ids 表中找到那个 string_data_off</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">stringIdsOff</span> <span class="operator">=</span> Utils.readInt(dexData, <span class="number">0x3C</span>); <span class="comment">// string_ids 的起始地址</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">stringDataOff</span> <span class="operator">=</span> Utils.readInt(dexData, stringIdsOff + stringIndex * <span class="number">4</span>); <span class="comment">// 找到该字符串的偏移</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取实际字符串内容（记得是 ULEB128 编码）</span></span><br><span class="line">    <span class="type">int</span>[] result = Utils.readUleb128(dexData, stringDataOff);</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> result[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> stringDataOff + result[<span class="number">1</span>];</span><br><span class="line">    <span class="type">String</span> <span class="variable">typeString</span> <span class="operator">=</span> Utils.readString(dexData, offset); <span class="comment">// 实际读取字符串内容</span></span><br><span class="line">    System.out.println(<span class="string">&quot;type[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + typeString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="proto-ids"><a href="#proto-ids" class="headerlink" title="proto_ids"></a>proto_ids</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexProtoId</span> &#123;</span></span><br><span class="line">    u4  shortyIdx;          <span class="comment">/* index into stringIds for shorty descriptor */</span></span><br><span class="line">    u4  returnTypeIdx;      <span class="comment">/* index into typeIds list for return type */</span></span><br><span class="line">    u4  parametersOff;      <span class="comment">/* file offset to type_list for parameter types */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>proto_ids</code> 表示方法声明信息，它包含以下三个变量：</p>
<ul>
<li>shortyIdx : 指向 string_ids ，表示方法声明的字符串</li>
<li>returnTypeIdx : 指向 type_ids ，表示方法的返回类型</li>
<li>parametersOff ： 方法参数列表的偏移量<br>方法参数列表的数据结构在 DexFile.h 中用 <code>DexTypeList</code> 来表示：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexTypeList</span> &#123;</span></span><br><span class="line">    u4  size;               <span class="comment">/* #of entries in list */</span></span><br><span class="line">    DexTypeItem <span class="built_in">list</span>[<span class="number">1</span>];    <span class="comment">/* entries */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexTypeItem</span> &#123;</span></span><br><span class="line">    u2  typeIdx;            <span class="comment">/* index into typeIds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>size</code> 表示方法参数的个数，参数用 <code>DexTypeItem</code> 表示，它只有一个属性 <code>typeIdx</code>，指向 <code>type_ids</code> 中对应项。</p>
<p>解析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DexProtoParser</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 读取整个 dex 文件内容到 byte[] 中</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;your.dex&quot;</span>); <span class="comment">// 修改为实际路径</span></span><br><span class="line">        <span class="type">byte</span>[] dexData = fis.readAllBytes();</span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用解析方法</span></span><br><span class="line">        parseProtoIds(dexData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 proto_ids 表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parseProtoIds</span><span class="params">(<span class="type">byte</span>[] dexData)</span> &#123;</span><br><span class="line">        <span class="comment">// 从 header 中读取 proto_ids 的数量和偏移地址</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">protoIdsSize</span> <span class="operator">=</span> readInt(dexData, <span class="number">0x44</span>);  <span class="comment">// proto_ids_size</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">protoIdsOff</span> <span class="operator">=</span> readInt(dexData, <span class="number">0x48</span>);   <span class="comment">// proto_ids_off</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Total proto_ids: &quot;</span> + protoIdsSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; protoIdsSize; i++) &#123;</span><br><span class="line">            <span class="comment">// 每个 proto_id 项固定占 12 字节</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> protoIdsOff + i * <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">shortyIdx</span> <span class="operator">=</span> readInt(dexData, base);          <span class="comment">// 指向 string_ids 表，用于描述方法签名（shorty）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">returnTypeIdx</span> <span class="operator">=</span> readInt(dexData, base + <span class="number">4</span>);  <span class="comment">// 指向 type_ids，表示返回类型</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">parametersOff</span> <span class="operator">=</span> readInt(dexData, base + <span class="number">8</span>);  <span class="comment">// 偏移到参数类型表（type_list）</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取字符串表示</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">shorty</span> <span class="operator">=</span> getStringById(dexData, shortyIdx);</span><br><span class="line">            <span class="type">String</span> <span class="variable">returnType</span> <span class="operator">=</span> getTypeString(dexData, returnTypeIdx);</span><br><span class="line">            String[] params = getParamTypeList(dexData, parametersOff);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印解析结果</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;proto[%d]: shorty=%s, return=%s, params=%s\n&quot;</span>,</span><br><span class="line">                    i, shorty, returnType, String.join(<span class="string">&quot;, &quot;</span>, params));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 byte[] 中读取一个小端 4 字节整数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">readInt</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((data[offset] &amp; <span class="number">0xFF</span>)) |</span><br><span class="line">               ((data[offset + <span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">               ((data[offset + <span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">               ((data[offset + <span class="number">3</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 ULEB128（可变长度整型编码），返回：[值，占用字节数]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] readUleb128(<span class="type">byte</span>[] data, <span class="type">int</span> offset) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">shift</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            b = data[offset + count] &amp; <span class="number">0xFF</span>;</span><br><span class="line">            result |= (b &amp; <span class="number">0x7F</span>) &lt;&lt; shift;</span><br><span class="line">            shift += <span class="number">7</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((b &amp; <span class="number">0x80</span>) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;result, count&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取字符串：string_ids → string_data_item → UTF-8字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getStringById</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> stringId)</span> &#123;</span><br><span class="line">        <span class="comment">// string_ids_off 存储在 header 的 0x3C 处</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">stringIdsOff</span> <span class="operator">=</span> readInt(data, <span class="number">0x3C</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每个 string_id 占 4 字节，值是 string_data_item 的偏移地址</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">stringDataOff</span> <span class="operator">=</span> readInt(data, stringIdsOff + stringId * <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过前面的 uleb128（表示 utf16 字符长度），读取 UTF-8 内容</span></span><br><span class="line">        <span class="type">int</span>[] result = readUleb128(data, stringDataOff);</span><br><span class="line">        <span class="type">int</span> <span class="variable">contentOffset</span> <span class="operator">=</span> stringDataOff + result[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> readString(data, contentOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 type_ids 中获取类型描述字符串（例如 Ljava/lang/String;）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getTypeString</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> typeIdx)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">typeIdsOff</span> <span class="operator">=</span> readInt(data, <span class="number">0x40</span>); <span class="comment">// header 中的 type_ids_off</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">descriptorIdx</span> <span class="operator">=</span> readInt(data, typeIdsOff + typeIdx * <span class="number">4</span>); <span class="comment">// 指向 string_ids</span></span><br><span class="line">        <span class="keyword">return</span> getStringById(data, descriptorIdx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 type_list（参数类型列表）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] getParamTypeList(<span class="type">byte</span>[] data, <span class="type">int</span> parametersOff) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parametersOff == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]; <span class="comment">// 没有参数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取参数数量（4字节）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> readInt(data, parametersOff);</span><br><span class="line">        String[] types = <span class="keyword">new</span> <span class="title class_">String</span>[size];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每个参数类型索引占 2 字节（type_idx）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">typeIdx</span> <span class="operator">=</span> ((data[parametersOff + <span class="number">4</span> + i * <span class="number">2</span>] &amp; <span class="number">0xFF</span>)</span><br><span class="line">                         | ((data[parametersOff + <span class="number">4</span> + i * <span class="number">2</span> + <span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>));</span><br><span class="line">            types[i] = getTypeString(data, typeIdx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> types;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 null 结尾的 UTF-8 字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readString</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> offset;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; data.length &amp;&amp; data[end] != <span class="number">0</span>) &#123;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(data, offset, end - offset, StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="field-ids"><a href="#field-ids" class="headerlink" title="field_ids"></a>field_ids</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexFieldId</span> &#123;</span></span><br><span class="line">    u2  classIdx;           <span class="comment">/* index into typeIds list for defining class */</span></span><br><span class="line">    u2  typeIdx;            <span class="comment">/* index into typeIds for field type */</span></span><br><span class="line">    u4  nameIdx;            <span class="comment">/* index into stringIds for field name */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>field_ids</code> 表示的是字段信息，指明了字段所在的类，字段的类型以及字段名称，在 <code>DexFile.h</code> 中定义为 <code>DexFieldId</code> , 其各个字段含义如下：</p>
<ul>
<li>classIdx : 指向 type_ids ，表示字段所在类的信息</li>
<li>typeIdx : 指向 ype_ids ，表示字段的类型信息</li>
<li>nameIdx : 指向 string_ids ，表示字段名称</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DexFieldParser</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;your.dex&quot;</span>); <span class="comment">// 替换成实际 dex 路径</span></span><br><span class="line">        <span class="type">byte</span>[] dexData = fis.readAllBytes();</span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line">        parseFieldIds(dexData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parseFieldIds</span><span class="params">(<span class="type">byte</span>[] dexData)</span> &#123;</span><br><span class="line">        <span class="comment">// 读取 header 中 field_ids 的数量和偏移</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fieldIdsSize</span> <span class="operator">=</span> readInt(dexData, <span class="number">0x58</span>); <span class="comment">// field_ids_size</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fieldIdsOff</span> <span class="operator">=</span> readInt(dexData, <span class="number">0x5C</span>);  <span class="comment">// field_ids_off</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Total field_ids: &quot;</span> + fieldIdsSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fieldIdsSize; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> fieldIdsOff + i * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">classIdx</span> <span class="operator">=</span> readU2(dexData, base);       <span class="comment">// 指向 declaring class (type_ids 索引)</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">typeIdx</span> <span class="operator">=</span> readU2(dexData, base + <span class="number">2</span>);    <span class="comment">// 指向 field type (type_ids 索引)</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nameIdx</span> <span class="operator">=</span> readInt(dexData, base + <span class="number">4</span>);   <span class="comment">// 指向 field name (string_ids 索引)</span></span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">classType</span> <span class="operator">=</span> getTypeString(dexData, classIdx);</span><br><span class="line">            <span class="type">String</span> <span class="variable">fieldType</span> <span class="operator">=</span> getTypeString(dexData, typeIdx);</span><br><span class="line">            <span class="type">String</span> <span class="variable">fieldName</span> <span class="operator">=</span> getStringById(dexData, nameIdx);</span><br><span class="line"></span><br><span class="line">            System.out.printf(<span class="string">&quot;field[%d]: class=%s, type=%s, name=%s\n&quot;</span>, i, classType, fieldType, fieldName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取小端 4 字节整数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">readInt</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (data[offset] &amp; <span class="number">0xFF</span>)</span><br><span class="line">             | ((data[offset + <span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">             | ((data[offset + <span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">             | ((data[offset + <span class="number">3</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取小端 2 字节整数（U2）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">readU2</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (data[offset] &amp; <span class="number">0xFF</span>)</span><br><span class="line">             | ((data[offset + <span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 string_id → string_data → UTF-8 字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getStringById</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> stringId)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stringIdsOff</span> <span class="operator">=</span> readInt(data, <span class="number">0x3C</span>); <span class="comment">// string_ids_off</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">stringDataOff</span> <span class="operator">=</span> readInt(data, stringIdsOff + stringId * <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] uleb = readUleb128(data, stringDataOff);</span><br><span class="line">        <span class="type">int</span> <span class="variable">stringOffset</span> <span class="operator">=</span> stringDataOff + uleb[<span class="number">1</span>]; <span class="comment">// 跳过 uleb128 的字符长度</span></span><br><span class="line">        <span class="keyword">return</span> readString(data, stringOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 type_id → string_id → string_data → UTF-8 类型字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getTypeString</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> typeId)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">typeIdsOff</span> <span class="operator">=</span> readInt(data, <span class="number">0x40</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">descriptorIdx</span> <span class="operator">=</span> readInt(data, typeIdsOff + typeId * <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">return</span> getStringById(data, descriptorIdx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 null 结尾 UTF-8 字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readString</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> offset;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; data.length &amp;&amp; data[end] != <span class="number">0</span>) &#123;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(data, offset, end - offset, StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 ULEB128 编码，返回：值 + 占用字节数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] readUleb128(<span class="type">byte</span>[] data, <span class="type">int</span> offset) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">shift</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            b = data[offset + count] &amp; <span class="number">0xFF</span>;</span><br><span class="line">            result |= (b &amp; <span class="number">0x7F</span>) &lt;&lt; shift;</span><br><span class="line">            shift += <span class="number">7</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((b &amp; <span class="number">0x80</span>) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;result, count&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="method-ids"><a href="#method-ids" class="headerlink" title="method_ids"></a>method_ids</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMethodId</span> &#123;</span></span><br><span class="line">    u2  classIdx;           <span class="comment">/* index into typeIds list for defining class */</span></span><br><span class="line">    u2  protoIdx;           <span class="comment">/* index into protoIds for method prototype */</span></span><br><span class="line">    u4  nameIdx;            <span class="comment">/* index into stringIds for method name */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>method_ids</code> 指明了方法所在的类、方法声明以及方法名。在 DexFile.h 中用 <code>DexMethodId</code> 表示该项，其属性含义如下：</p>
<ul>
<li>classIdx : 指向 type_ids ，表示类的类型</li>
<li>protoIdx : 指向 type_ids ，表示方法声明</li>
<li>nameIdx : 指向 string_ids ，表示方法名</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DexMethodParser</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;your.dex&quot;</span>); <span class="comment">// 替换为实际 dex 文件路径</span></span><br><span class="line">        <span class="type">byte</span>[] dexData = fis.readAllBytes();</span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line">        parseMethodIds(dexData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parseMethodIds</span><span class="params">(<span class="type">byte</span>[] dexData)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">methodIdsSize</span> <span class="operator">=</span> readInt(dexData, <span class="number">0x60</span>); <span class="comment">// method_ids_size 偏移为 0x60</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">methodIdsOff</span> <span class="operator">=</span> readInt(dexData, <span class="number">0x64</span>);  <span class="comment">// method_ids_off 偏移为 0x64</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Total method_ids: &quot;</span> + methodIdsSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; methodIdsSize; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> methodIdsOff + i * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">classIdx</span> <span class="operator">=</span> readU2(dexData, base);       <span class="comment">// method 所属类，type_ids 的索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">protoIdx</span> <span class="operator">=</span> readU2(dexData, base + <span class="number">2</span>);   <span class="comment">// 方法的签名结构，proto_ids 的索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nameIdx</span> <span class="operator">=</span> readInt(dexData, base + <span class="number">4</span>);   <span class="comment">// 方法名字符串，string_ids 的索引</span></span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">classType</span> <span class="operator">=</span> getTypeString(dexData, classIdx);</span><br><span class="line">            <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> getStringById(dexData, nameIdx);</span><br><span class="line">            <span class="type">String</span> <span class="variable">protoDesc</span> <span class="operator">=</span> getProtoString(dexData, protoIdx);</span><br><span class="line"></span><br><span class="line">            System.out.printf(<span class="string">&quot;method[%d]: class=%s, proto=%s, name=%s\n&quot;</span>, i, classType, protoDesc, methodName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ----------- 以下是通用辅助方法 ------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">readInt</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (data[offset] &amp; <span class="number">0xFF</span>)</span><br><span class="line">             | ((data[offset + <span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">             | ((data[offset + <span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">             | ((data[offset + <span class="number">3</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">readU2</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (data[offset] &amp; <span class="number">0xFF</span>)</span><br><span class="line">             | ((data[offset + <span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getStringById</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> stringId)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stringIdsOff</span> <span class="operator">=</span> readInt(data, <span class="number">0x3C</span>); <span class="comment">// string_ids_off</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">stringDataOff</span> <span class="operator">=</span> readInt(data, stringIdsOff + stringId * <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] uleb = readUleb128(data, stringDataOff);</span><br><span class="line">        <span class="type">int</span> <span class="variable">stringOffset</span> <span class="operator">=</span> stringDataOff + uleb[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> readString(data, stringOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getTypeString</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> typeId)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">typeIdsOff</span> <span class="operator">=</span> readInt(data, <span class="number">0x40</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">descriptorIdx</span> <span class="operator">=</span> readInt(data, typeIdsOff + typeId * <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">return</span> getStringById(data, descriptorIdx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getProtoString</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> protoId)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">protoIdsOff</span> <span class="operator">=</span> readInt(data, <span class="number">0x44</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> protoIdsOff + protoId * <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">shortyIdx</span> <span class="operator">=</span> readInt(data, base);</span><br><span class="line">        <span class="type">int</span> <span class="variable">returnTypeIdx</span> <span class="operator">=</span> readInt(data, base + <span class="number">4</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">parametersOff</span> <span class="operator">=</span> readInt(data, base + <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">returnType</span> <span class="operator">=</span> getTypeString(data, returnTypeIdx);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parametersOff != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> readInt(data, parametersOff);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">typeIdx</span> <span class="operator">=</span> readU2(data, parametersOff + <span class="number">4</span> + i * <span class="number">2</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">typeStr</span> <span class="operator">=</span> getTypeString(data, typeIdx);</span><br><span class="line">                params.append(typeStr);</span><br><span class="line">                <span class="keyword">if</span> (i != size - <span class="number">1</span>) &#123;</span><br><span class="line">                    params.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + params + <span class="string">&quot;) → &quot;</span> + returnType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readString</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> offset;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; data.length &amp;&amp; data[end] != <span class="number">0</span>) &#123;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(data, offset, end - offset, StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] readUleb128(<span class="type">byte</span>[] data, <span class="type">int</span> offset) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">shift</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            b = data[offset + count] &amp; <span class="number">0xFF</span>;</span><br><span class="line">            result |= (b &amp; <span class="number">0x7F</span>) &lt;&lt; shift;</span><br><span class="line">            shift += <span class="number">7</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((b &amp; <span class="number">0x80</span>) != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;result, count&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="class-def"><a href="#class-def" class="headerlink" title="class_def"></a>class_def</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexClassDef</span> &#123;</span></span><br><span class="line">    u4  classIdx;           <span class="comment">/* index into typeIds for this class */</span></span><br><span class="line">    u4  accessFlags;</span><br><span class="line">    u4  superclassIdx;      <span class="comment">/* index into typeIds for superclass */</span></span><br><span class="line">    u4  interfacesOff;      <span class="comment">/* file offset to DexTypeList */</span></span><br><span class="line">    u4  sourceFileIdx;      <span class="comment">/* index into stringIds for source file name */</span></span><br><span class="line">    u4  annotationsOff;     <span class="comment">/* file offset to annotations_directory_item */</span></span><br><span class="line">    u4  classDataOff;       <span class="comment">/* file offset to class_data_item */</span></span><br><span class="line">    u4  staticValuesOff;    <span class="comment">/* file offset to DexEncodedArray */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>class_def</code> 是 DEX 文件结构中最复杂也是最核心的部分，它表示了类的所有信息，对应 <code>DexFile.h</code> 中的 <code>DexClassDef</code> :</p>
<ul>
<li>classIdx : 指向 type_ids ，表示类信息</li>
<li>accessFlags : 访问标识符</li>
<li>superclassIdx : 指向 type_ids ，表示父类信息</li>
<li>interfacesOff : 指向 DexTypeList 的偏移量，表示接口信息</li>
<li>sourceFileIdx : 指向 string_ids ，表示源文件名称</li>
<li>annotationOff : 注解信息</li>
<li>classDataOff : 指向 DexClassData 的偏移量，表示类的数据部分</li>
<li>staticValueOff :指向 DexEncodedArray 的偏移量，表示类的静态数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DexClassDefsParser</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;your.dex&quot;</span>); <span class="comment">// 将 &quot;your.dex&quot; 替换为你的 dex 文件路径</span></span><br><span class="line">        <span class="type">byte</span>[] dexData = fis.readAllBytes(); <span class="comment">// 读取整个 dex 文件为字节数组</span></span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line">        parseClassDefs(dexData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parseClassDefs</span><span class="params">(<span class="type">byte</span>[] dexData)</span> &#123;</span><br><span class="line">        <span class="comment">// 读取 class_defs_size（类定义数量），偏移地址 0x70</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">classDefsSize</span> <span class="operator">=</span> readInt(dexData, <span class="number">0x70</span>);</span><br><span class="line">        <span class="comment">// 读取 class_defs_off（类定义开始偏移），偏移地址 0x74</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">classDefsOff</span> <span class="operator">=</span> readInt(dexData, <span class="number">0x74</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Total class_defs: &quot;</span> + classDefsSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每一个 class_def 项，每项固定 32 字节</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; classDefsSize; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> classDefsOff + i * <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">classIdx</span> <span class="operator">=</span> readInt(dexData, base);           <span class="comment">// 当前类在 type_ids 中的索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">accessFlags</span> <span class="operator">=</span> readInt(dexData, base + <span class="number">4</span>);    <span class="comment">// 访问标志（public、final 等）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">superClassIdx</span> <span class="operator">=</span> readInt(dexData, base + <span class="number">8</span>);  <span class="comment">// 父类索引（type_ids）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">interfacesOff</span> <span class="operator">=</span> readInt(dexData, base + <span class="number">12</span>); <span class="comment">// 实现的接口偏移（指向 type_list）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sourceFileIdx</span> <span class="operator">=</span> readInt(dexData, base + <span class="number">16</span>); <span class="comment">// 源文件名在 string_ids 中的索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">annotationsOff</span> <span class="operator">=</span> readInt(dexData, base + <span class="number">20</span>);<span class="comment">// 注解偏移</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">classDataOff</span> <span class="operator">=</span> readInt(dexData, base + <span class="number">24</span>);  <span class="comment">// 类字段/方法数据偏移</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">staticValuesOff</span> <span class="operator">=</span> readInt(dexData, base + <span class="number">28</span>);<span class="comment">// 静态变量初始值偏移</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取类名、父类名和源文件名字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> getTypeString(dexData, classIdx);</span><br><span class="line">            <span class="type">String</span> <span class="variable">superClassName</span> <span class="operator">=</span> getTypeString(dexData, superClassIdx);</span><br><span class="line">            <span class="type">String</span> <span class="variable">sourceFile</span> <span class="operator">=</span> getStringById(dexData, sourceFileIdx);</span><br><span class="line"></span><br><span class="line">            System.out.printf(<span class="string">&quot;class[%d]: %s extends %s from [%s], class_data_off=0x%x\n&quot;</span>,</span><br><span class="line">                    i, className, superClassName, sourceFile, classDataOff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------ 工具方法部分 ------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从指定偏移读取 4 字节，按小端格式转换为 int</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">readInt</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (data[offset] &amp; <span class="number">0xFF</span>)</span><br><span class="line">             | ((data[offset + <span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">             | ((data[offset + <span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">             | ((data[offset + <span class="number">3</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 type_id 取出对应的类型字符串（如 Ljava/lang/String;）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getTypeString</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> typeId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (typeId &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">typeIdsOff</span> <span class="operator">=</span> readInt(data, <span class="number">0x40</span>); <span class="comment">// type_ids 起始偏移，0x40 位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">descriptorIdx</span> <span class="operator">=</span> readInt(data, typeIdsOff + typeId * <span class="number">4</span>); <span class="comment">// 每个 type_id 对应一个 string_id</span></span><br><span class="line">        <span class="keyword">return</span> getStringById(data, descriptorIdx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 string_id 取出对应的字符串内容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getStringById</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> stringId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stringId &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stringIdsOff</span> <span class="operator">=</span> readInt(data, <span class="number">0x3C</span>); <span class="comment">// string_ids 起始偏移，0x3C 位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">stringDataOff</span> <span class="operator">=</span> readInt(data, stringIdsOff + stringId * <span class="number">4</span>); <span class="comment">// 获取该字符串的偏移</span></span><br><span class="line">        <span class="type">int</span>[] uleb = readUleb128(data, stringDataOff); <span class="comment">// 前缀是 ULEB128 格式的字符串长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> stringDataOff + uleb[<span class="number">1</span>]; <span class="comment">// 字符串实际数据起始位置</span></span><br><span class="line">        <span class="keyword">return</span> readString(data, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 offset 开始读取一个以 0 结尾的字符串（UTF-8 编码）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readString</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> offset;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; data.length &amp;&amp; data[end] != <span class="number">0</span>) end++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(data, offset, end - offset, StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取一个 ULEB128 编码整数，返回 [值, 所占字节数]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] readUleb128(<span class="type">byte</span>[] data, <span class="type">int</span> offset) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">shift</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            b = data[offset + count] &amp; <span class="number">0xFF</span>;</span><br><span class="line">            result |= (b &amp; <span class="number">0x7F</span>) &lt;&lt; shift;</span><br><span class="line">            shift += <span class="number">7</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((b &amp; <span class="number">0x80</span>) != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;result, count&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DefCLassData"><a href="#DefCLassData" class="headerlink" title="DefCLassData"></a>DefCLassData</h4><p>重点是 <code>classDataOff</code> 这个字段，它包含了一个类的核心数据，在 Android 源码中定义为 <code>DexClassData</code> ，它不在 DexFile.h 中了，而是在 DexClass.h 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexClassData</span> &#123;</span></span><br><span class="line">    DexClassDataHeader header;</span><br><span class="line">    DexField*          staticFields;</span><br><span class="line">    DexField*          instanceFields;</span><br><span class="line">    DexMethod*         directMethods;</span><br><span class="line">    DexMethod*         virtualMethods;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>DexClassDataHeader</code> 定义了类中字段和方法的数目，它也定义在 DexClass.h 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexClassDataHeader</span> &#123;</span></span><br><span class="line">    u4 staticFieldsSize;</span><br><span class="line">    u4 instanceFieldsSize;</span><br><span class="line">    u4 directMethodsSize;</span><br><span class="line">    u4 virtualMethodsSize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>staticFieldsSize : 静态字段个数</li>
<li>instanceFieldsSize : 实例字段个数</li>
<li>directMethodsSize : 直接方法个数</li>
<li>virtualMethodsSize : 虚方法个数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DexClassDataParser</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parseClassData</span><span class="params">(<span class="type">byte</span>[] dexData, <span class="type">int</span> classDataOff)</span> &#123;</span><br><span class="line">        <span class="comment">// 解析 class_data_item（32 字节结构）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">staticFieldsSize</span> <span class="operator">=</span> readUleb128(dexData, classDataOff)[<span class="number">0</span>];  <span class="comment">// 静态字段数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">instanceFieldsSize</span> <span class="operator">=</span> readUleb128(dexData, classDataOff + <span class="number">1</span>)[<span class="number">0</span>];  <span class="comment">// 实例字段数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">directMethodsSize</span> <span class="operator">=</span> readUleb128(dexData, classDataOff + <span class="number">2</span>)[<span class="number">0</span>];  <span class="comment">// 直接方法数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">virtualMethodsSize</span> <span class="operator">=</span> readUleb128(dexData, classDataOff + <span class="number">3</span>)[<span class="number">0</span>];  <span class="comment">// 虚拟方法数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印解析出来的字段数量信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Static Fields: &quot;</span> + staticFieldsSize);</span><br><span class="line">        System.out.println(<span class="string">&quot;Instance Fields: &quot;</span> + instanceFieldsSize);</span><br><span class="line">        System.out.println(<span class="string">&quot;Direct Methods: &quot;</span> + directMethodsSize);</span><br><span class="line">        System.out.println(<span class="string">&quot;Virtual Methods: &quot;</span> + virtualMethodsSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态字段解析</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">currentOffset</span> <span class="operator">=</span> classDataOff + <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; staticFieldsSize; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fieldId</span> <span class="operator">=</span> readUleb128(dexData, currentOffset)[<span class="number">0</span>]; <span class="comment">// 获取字段 ID</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fieldName</span> <span class="operator">=</span> getFieldName(dexData, fieldId);</span><br><span class="line">            System.out.println(<span class="string">&quot;Static Field [&quot;</span> + i + <span class="string">&quot;]: &quot;</span> + fieldName);</span><br><span class="line">            currentOffset += <span class="number">1</span>; <span class="comment">// 偏移量调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例字段解析</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; instanceFieldsSize; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fieldId</span> <span class="operator">=</span> readUleb128(dexData, currentOffset)[<span class="number">0</span>]; <span class="comment">// 获取字段 ID</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fieldName</span> <span class="operator">=</span> getFieldName(dexData, fieldId);</span><br><span class="line">            System.out.println(<span class="string">&quot;Instance Field [&quot;</span> + i + <span class="string">&quot;]: &quot;</span> + fieldName);</span><br><span class="line">            currentOffset += <span class="number">1</span>; <span class="comment">// 偏移量调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接方法解析</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; directMethodsSize; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">methodId</span> <span class="operator">=</span> readUleb128(dexData, currentOffset)[<span class="number">0</span>]; <span class="comment">// 获取方法 ID</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> getMethodName(dexData, methodId);</span><br><span class="line">            System.out.println(<span class="string">&quot;Direct Method [&quot;</span> + i + <span class="string">&quot;]: &quot;</span> + methodName);</span><br><span class="line">            currentOffset += <span class="number">1</span>; <span class="comment">// 偏移量调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 虚拟方法解析</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; virtualMethodsSize; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">methodId</span> <span class="operator">=</span> readUleb128(dexData, currentOffset)[<span class="number">0</span>]; <span class="comment">// 获取方法 ID</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> getMethodName(dexData, methodId);</span><br><span class="line">            System.out.println(<span class="string">&quot;Virtual Method [&quot;</span> + i + <span class="string">&quot;]: &quot;</span> + methodName);</span><br><span class="line">            currentOffset += <span class="number">1</span>; <span class="comment">// 偏移量调整</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------ 工具方法部分 ------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取一个 ULEB128 编码整数，返回 [值, 所占字节数]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] readUleb128(<span class="type">byte</span>[] data, <span class="type">int</span> offset) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">shift</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            b = data[offset + count] &amp; <span class="number">0xFF</span>;</span><br><span class="line">            result |= (b &amp; <span class="number">0x7F</span>) &lt;&lt; shift;</span><br><span class="line">            shift += <span class="number">7</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((b &amp; <span class="number">0x80</span>) != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;result, count&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据字段 ID 获取字段名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getFieldName</span><span class="params">(<span class="type">byte</span>[] dexData, <span class="type">int</span> fieldId)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fieldIdsOff</span> <span class="operator">=</span> readInt(dexData, <span class="number">0x80</span>); <span class="comment">// 获取 field_ids 的偏移</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fieldIdOffset</span> <span class="operator">=</span> readInt(dexData, fieldIdsOff + fieldId * <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">return</span> getStringById(dexData, fieldIdOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据方法 ID 获取方法名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getMethodName</span><span class="params">(<span class="type">byte</span>[] dexData, <span class="type">int</span> methodId)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">methodIdsOff</span> <span class="operator">=</span> readInt(dexData, <span class="number">0x84</span>); <span class="comment">// 获取 method_ids 的偏移</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">methodIdOffset</span> <span class="operator">=</span> readInt(dexData, methodIdsOff + methodId * <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">return</span> getStringById(dexData, methodIdOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从指定偏移读取 4 字节，按小端格式转换为 int</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">readInt</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (data[offset] &amp; <span class="number">0xFF</span>)</span><br><span class="line">             | ((data[offset + <span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">             | ((data[offset + <span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">             | ((data[offset + <span class="number">3</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 string_id 获取字符串内容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getStringById</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> stringId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stringId &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stringIdsOff</span> <span class="operator">=</span> readInt(data, <span class="number">0x3C</span>); <span class="comment">// string_ids 起始偏移，0x3C 位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">stringDataOff</span> <span class="operator">=</span> readInt(data, stringIdsOff + stringId * <span class="number">4</span>); <span class="comment">// 获取该字符串的偏移</span></span><br><span class="line">        <span class="keyword">return</span> readString(data, stringDataOff);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 offset 开始读取一个以 0 结尾的字符串（UTF-8 编码）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readString</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> offset;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; data.length &amp;&amp; data[end] != <span class="number">0</span>) end++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(data, offset, end - offset, StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续回到 DexClassData 中来。<code>header</code> 部分定义了各种字段和方法的个数，后面跟着的分别就是 <strong>静态字段</strong> 、<strong>实例字段</strong> 、<strong>直接方法</strong> 、<strong>虚方法</strong> 的具体数据了。字段用 <code>DexField</code> 表示，方法用 <code>DexMethod</code> 表示。</p>
<h4 id="DexField"><a href="#DexField" class="headerlink" title="DexField"></a>DexField</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexField</span> &#123;</span></span><br><span class="line">    u4 fieldIdx;    <span class="comment">/* index to a field_id_item */</span></span><br><span class="line">    u4 accessFlags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>fieldIdx : 指向 field_ids ，表示字段信息</li>
<li>accessFlags ：访问标识符</li>
</ul>
<h4 id="DexMethod"><a href="#DexMethod" class="headerlink" title="DexMethod"></a>DexMethod</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMethod</span> &#123;</span></span><br><span class="line">    u4 methodIdx;    <span class="comment">/* index to a method_id_item */</span></span><br><span class="line">    u4 accessFlags;</span><br><span class="line">    u4 codeOff;      <span class="comment">/* file offset to a code_item */</span></span><br><span class="line"><span class="number">46</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><code>method_idx</code> 是指向 method_ids 的索引，表示方法信息。<br><code>accessFlags</code> 是该方法的访问标识符。<code>codeOff</code> 是结构体 <code>DexCode</code> 的偏移量</p>
<h4 id="DexCode"><a href="#DexCode" class="headerlink" title="DexCode"></a>DexCode</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexCode</span> &#123;</span></span><br><span class="line">    u2  registersSize;  <span class="comment">// 寄存器个数</span></span><br><span class="line">    u2  insSize;        <span class="comment">// 参数的个数</span></span><br><span class="line">    u2  outsSize;       <span class="comment">// 调用其他方法时使用的寄存器个数</span></span><br><span class="line">    u2  triesSize;      <span class="comment">// try/catch 语句个数</span></span><br><span class="line">    u4  debugInfoOff;   <span class="comment">// debug 信息的偏移量</span></span><br><span class="line">    u4  insnsSize;      <span class="comment">// 指令集的个数</span></span><br><span class="line">    u2  insns[<span class="number">1</span>];       <span class="comment">// 指令集</span></span><br><span class="line">    <span class="comment">/* followed by optional u2 padding */</span>  <span class="comment">// 2 字节，用于对齐</span></span><br><span class="line">    <span class="comment">/* followed by try_item[triesSize] */</span></span><br><span class="line">    <span class="comment">/* followed by uleb128 handlersSize */</span></span><br><span class="line">    <span class="comment">/* followed by catch_handler_item[handlersSize] */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DexCodeParser</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parseDexCode</span><span class="params">(<span class="type">byte</span>[] dexData, <span class="type">int</span> codeOffset)</span> &#123;</span><br><span class="line">        <span class="comment">// 解析寄存器数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">registersSize</span> <span class="operator">=</span> readShort(dexData, codeOffset);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解析输入指令数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">insSize</span> <span class="operator">=</span> readShort(dexData, codeOffset + <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解析输出指令数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">outsSize</span> <span class="operator">=</span> readShort(dexData, codeOffset + <span class="number">4</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解析异常处理块数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">triesSize</span> <span class="operator">=</span> readShort(dexData, codeOffset + <span class="number">6</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解析调试信息的偏移</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">debugInfoOffset</span> <span class="operator">=</span> readInt(dexData, codeOffset + <span class="number">8</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解析指令集大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">insnsSize</span> <span class="operator">=</span> readInt(dexData, codeOffset + <span class="number">12</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解析字节码指令</span></span><br><span class="line">        <span class="type">byte</span>[] insns = <span class="keyword">new</span> <span class="title class_">byte</span>[insnsSize];</span><br><span class="line">        System.arraycopy(dexData, codeOffset + <span class="number">16</span>, insns, <span class="number">0</span>, insnsSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印解析的字节码信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Registers Size: &quot;</span> + registersSize);</span><br><span class="line">        System.out.println(<span class="string">&quot;Ins Size: &quot;</span> + insSize);</span><br><span class="line">        System.out.println(<span class="string">&quot;Outs Size: &quot;</span> + outsSize);</span><br><span class="line">        System.out.println(<span class="string">&quot;Tries Size: &quot;</span> + triesSize);</span><br><span class="line">        System.out.println(<span class="string">&quot;Debug Info Offset: &quot;</span> + debugInfoOffset);</span><br><span class="line">        System.out.println(<span class="string">&quot;Insns Size: &quot;</span> + insnsSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析字节码指令</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; insnsSize; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;0x%02X &quot;</span>, insns[i]);</span><br><span class="line">            <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 2 字节的小端数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">readShort</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (data[offset] &amp; <span class="number">0xFF</span>) | ((data[offset + <span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 4 字节的小端数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">readInt</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (data[offset] &amp; <span class="number">0xFF</span>)</span><br><span class="line">             | ((data[offset + <span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">             | ((data[offset + <span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">             | ((data[offset + <span class="number">3</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h2><p>参考： <a target="_blank" rel="noopener" href="https://ctf-wiki.org/executable/elf/structure/basic-info/">https://ctf-wiki.org/executable/elf/structure/basic-info/</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/aDbrS_PE_i8Xt7-zZe2v9A">https://mp.weixin.qq.com/s/aDbrS_PE_i8Xt7-zZe2v9A</a></p>
<img src="/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250413174113482.png" class="">
<h3 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h3><p>ELF Header 描述了 ELF 文件的概要信息，利用这个数据结构可以索引到 ELF 文件的全部信息，数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> e_ident[<span class="number">16</span>];  <span class="comment">// 魔数，标识为 ELF</span></span><br><span class="line">    <span class="type">uint16_t</span> e_type;            <span class="comment">// 文件类型（可执行文件、目标文件等）</span></span><br><span class="line">    <span class="type">uint16_t</span> e_machine;         <span class="comment">// 架构（如 x86）</span></span><br><span class="line">    <span class="type">uint32_t</span> e_version;</span><br><span class="line">    <span class="type">uint64_t</span> e_entry;           <span class="comment">// 程序入口地址</span></span><br><span class="line">    <span class="type">uint64_t</span> e_phoff;           <span class="comment">// 程序头表偏移</span></span><br><span class="line">    <span class="type">uint64_t</span> e_shoff;           <span class="comment">// 节区头表偏移</span></span><br><span class="line">    <span class="type">uint32_t</span> e_flags;</span><br><span class="line">    <span class="type">uint16_t</span> e_ehsize;          <span class="comment">// ELF Header 大小</span></span><br><span class="line">    <span class="type">uint16_t</span> e_phentsize;       <span class="comment">// 每个 Program Header 大小</span></span><br><span class="line">    <span class="type">uint16_t</span> e_phnum;           <span class="comment">// Program Header 数量</span></span><br><span class="line">    <span class="type">uint16_t</span> e_shentsize;       <span class="comment">// 每个 Section Header 大小</span></span><br><span class="line">    <span class="type">uint16_t</span> e_shnum;           <span class="comment">// Section Header 数量</span></span><br><span class="line">    <span class="type">uint16_t</span> e_shstrndx;        <span class="comment">// 字符串表在 Section Header 表中的索引</span></span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure>

<h3 id="Program-Header"><a href="#Program-Header" class="headerlink" title="Program Header"></a>Program Header</h3><p>描述进程运行时如何加载 ELF 文件，比如 <code>.text</code> 和 <code>.data</code> 段的位置和权限等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> p_type;    <span class="comment">// 段类型</span></span><br><span class="line">    <span class="type">uint32_t</span> p_flags;   <span class="comment">// 段权限（rwx）</span></span><br><span class="line">    <span class="type">uint64_t</span> p_offset;  <span class="comment">// 在文件中的偏移</span></span><br><span class="line">    <span class="type">uint64_t</span> p_vaddr;   <span class="comment">// 在内存中的虚拟地址</span></span><br><span class="line">    <span class="type">uint64_t</span> p_paddr;   <span class="comment">// 物理地址</span></span><br><span class="line">    <span class="type">uint64_t</span> p_filesz;  <span class="comment">// 文件中该段的大小</span></span><br><span class="line">    <span class="type">uint64_t</span> p_memsz;   <span class="comment">// 内存中该段的大小</span></span><br><span class="line">    <span class="type">uint64_t</span> p_align;   <span class="comment">// 对齐方式</span></span><br><span class="line">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure>

<h4 id="Base-Address"><a href="#Base-Address" class="headerlink" title="Base Address"></a>Base Address</h4><p>要计算基地址，首先要确定可加载段中 p_vaddr 最小的内存虚拟地址，之后把该内存虚拟地址缩小为与之最近的最大页面的整数倍即是基地址。根据要加载到内存中的文件的类型，内存地址可能与 p_vaddr 相同也可能不同。</p>
<p>1.在 ELF 的 Program Header 表中查找 <code>p_type == PT_LOAD</code> 的段。</p>
<p>2.确定 <strong>最小的 <code>p_vaddr</code></strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Elf64_Addr min_vaddr = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ehdr.e_phnum; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (phdr[i].p_type == PT_LOAD) &#123;</span><br><span class="line">        <span class="keyword">if</span> (phdr[i].p_vaddr &lt; min_vaddr || min_vaddr == <span class="number">-1</span>) &#123;</span><br><span class="line">            min_vaddr = phdr[i].p_vaddr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.向下对齐（align）这个最小地址到页边界 一般都是 0x1000(4096)字节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0x1000</span></span><br><span class="line">Elf64_Addr base_vaddr = min_vaddr &amp; ~(PAGE_SIZE - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>4.在动态链接库（<code>.so</code>）或 PIE 文件（ET_DYN 类型）中：</p>
<ul>
<li>内核会将段加载到任意合适的内存地址上，比如：<code>0x7fabc00000</code></li>
<li>这个实际加载地址 - <code>base_vaddr</code> 就是我们要补偿的基地址（通常叫 <code>base_address</code>）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">real_address = base_address + p_vaddr;</span><br></pre></td></tr></table></figure>

<p>如果是非 PIE 的 <code>ET_EXEC</code> 类型，通常 <code>base_address == 0</code>，也就不需要做偏移调整。</p>
<h4 id="p-type"><a href="#p-type" class="headerlink" title="p_type"></a>p_type</h4><table>
<thead>
<tr>
<th>值</th>
<th>宏定义</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>0</code></td>
<td><code>PT_NULL</code></td>
<td>忽略</td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>PT_LOAD</code></td>
<td>可加载段（程序运行所需）</td>
</tr>
<tr>
<td><code>2</code></td>
<td><code>PT_DYNAMIC</code></td>
<td>动态链接信息段</td>
</tr>
<tr>
<td><code>3</code></td>
<td><code>PT_INTERP</code></td>
<td>解释器路径（比如 <code>/lib/ld-linux.so.2</code>）</td>
</tr>
<tr>
<td><code>4</code></td>
<td><code>PT_NOTE</code></td>
<td>各类注解</td>
</tr>
<tr>
<td><code>5</code></td>
<td><code>PT_SHLIB</code></td>
<td>保留</td>
</tr>
<tr>
<td><code>6</code></td>
<td><code>PT_PHDR</code></td>
<td>程序头自身所在段</td>
</tr>
<tr>
<td><code>0x6474e550</code></td>
<td><code>PT_GNU_EH_FRAME</code></td>
<td>GCC 的异常处理帧表</td>
</tr>
<tr>
<td><code>0x6474e551</code></td>
<td><code>PT_GNU_STACK</code></td>
<td>栈权限设定段（比如是否允许栈可执行）</td>
</tr>
</tbody></table>
<h3 id="Section-Header"><a href="#Section-Header" class="headerlink" title="Section Header"></a>Section Header</h3><p>描述每个节的名字、类型、偏移、大小等，比如 <code>.text</code>、<code>.data</code>、<code>.symtab</code>、<code>.strtab</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> sh_name;      <span class="comment">// 节名称的字符串表索引</span></span><br><span class="line">    <span class="type">uint32_t</span> sh_type;      <span class="comment">// 节的类型</span></span><br><span class="line">    <span class="type">uint64_t</span> sh_flags;     <span class="comment">// 标志（如可执行、可写）</span></span><br><span class="line">    <span class="type">uint64_t</span> sh_addr;      <span class="comment">// 节的地址</span></span><br><span class="line">    <span class="type">uint64_t</span> sh_offset;    <span class="comment">// 节在文件中的偏移</span></span><br><span class="line">    <span class="type">uint64_t</span> sh_size;      <span class="comment">// 节大小</span></span><br><span class="line">    <span class="type">uint32_t</span> sh_link;      <span class="comment">// 与其他节的关联</span></span><br><span class="line">    <span class="type">uint32_t</span> sh_info;      <span class="comment">// 附加信息</span></span><br><span class="line">    <span class="type">uint64_t</span> sh_addralign; <span class="comment">// 对齐</span></span><br><span class="line">    <span class="type">uint64_t</span> sh_entsize;   <span class="comment">// 如果是表格，单项大小</span></span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure>

<p>详细解释</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>sh_name</code></td>
<td>指向节名称字符串表（<code>.shstrtab</code>）的偏移，表示节的名字</td>
</tr>
<tr>
<td><code>sh_type</code></td>
<td>节的类型，常见类型见下方</td>
</tr>
<tr>
<td><code>sh_flags</code></td>
<td>节的属性，比如可写、可执行、可加载（<code>SHF_WRITE</code>, <code>SHF_EXECINSTR</code>, <code>SHF_ALLOC</code>）</td>
</tr>
<tr>
<td><code>sh_addr</code></td>
<td>该节在内存中的地址（如果可加载，否则为 0）</td>
</tr>
<tr>
<td><code>sh_offset</code></td>
<td>该节在文件中的偏移（用于读取节内容）</td>
</tr>
<tr>
<td><code>sh_size</code></td>
<td>节的字节大小</td>
</tr>
<tr>
<td><code>sh_link</code></td>
<td>依节类型而定，例如 <code>.symtab</code> 的 link 指向 <code>.strtab</code>（字符串表）</td>
</tr>
<tr>
<td><code>sh_info</code></td>
<td>附加信息，如 <code>.symtab</code> 中表示本地符号数量</td>
</tr>
<tr>
<td><code>sh_addralign</code></td>
<td>对齐值（2 的幂），决定节在内存&#x2F;文件中对齐边界</td>
</tr>
<tr>
<td><code>sh_entsize</code></td>
<td>如果节是一个“表”，这个字段表示每项的大小（如 <code>.symtab</code> 中一个符号的大小）</td>
</tr>
</tbody></table>
<h4 id="sh-type"><a href="#sh-type" class="headerlink" title="sh_type"></a>sh_type</h4><table>
<thead>
<tr>
<th>值</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>0</code></td>
<td><code>SHT_NULL</code></td>
<td>无效节头（第一个节保留）</td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>SHT_PROGBITS</code></td>
<td>普通数据，比如 <code>.text</code>, <code>.data</code></td>
</tr>
<tr>
<td><code>2</code></td>
<td><code>SHT_SYMTAB</code></td>
<td>符号表</td>
</tr>
<tr>
<td><code>3</code></td>
<td><code>SHT_STRTAB</code></td>
<td>字符串表</td>
</tr>
<tr>
<td><code>4</code></td>
<td><code>SHT_RELA</code></td>
<td>有符号重定位表</td>
</tr>
<tr>
<td><code>5</code></td>
<td><code>SHT_HASH</code></td>
<td>哈希表</td>
</tr>
<tr>
<td><code>6</code></td>
<td><code>SHT_DYNAMIC</code></td>
<td>动态链接信息表</td>
</tr>
<tr>
<td><code>7</code></td>
<td><code>SHT_NOTE</code></td>
<td>标注节（比如编译器信息）</td>
</tr>
<tr>
<td><code>8</code></td>
<td><code>SHT_NOBITS</code></td>
<td>不占文件空间的节（如 <code>.bss</code>）</td>
</tr>
<tr>
<td><code>9</code></td>
<td><code>SHT_REL</code></td>
<td>无偏移重定位表</td>
</tr>
<tr>
<td><code>0x0b</code></td>
<td><code>SHT_DYNSYM</code></td>
<td>动态符号表</td>
</tr>
</tbody></table>
<h4 id="sh-flags"><a href="#sh-flags" class="headerlink" title="sh_flags"></a>sh_flags</h4><table>
<thead>
<tr>
<th>标志名</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>SHF_WRITE</code></td>
<td><code>0x1</code></td>
<td>节可写</td>
</tr>
<tr>
<td><code>SHF_ALLOC</code></td>
<td><code>0x2</code></td>
<td>节会被加载进内存</td>
</tr>
<tr>
<td><code>SHF_EXECINSTR</code></td>
<td><code>0x4</code></td>
<td>节包含可执行指令</td>
</tr>
<tr>
<td><code>SHF_MERGE</code></td>
<td><code>0x10</code></td>
<td>内容可以合并（字符串表等）</td>
</tr>
<tr>
<td><code>SHF_STRINGS</code></td>
<td><code>0x20</code></td>
<td>节包含 null 结尾的字符串</td>
</tr>
<tr>
<td><code>SHF_INFO_LINK</code></td>
<td><code>0x40</code></td>
<td><code>sh_info</code> 字段与其他节有关</td>
</tr>
<tr>
<td><code>SHF_TLS</code></td>
<td><code>0x400</code></td>
<td>节用于线程本地存储</td>
</tr>
</tbody></table>
<h3 id="Program-Header-和-Section-header区别"><a href="#Program-Header-和-Section-header区别" class="headerlink" title="Program Header 和 Section header区别"></a>Program Header 和 Section header区别</h3><table>
<thead>
<tr>
<th>Program Header（段）</th>
<th>Section Header（节）</th>
</tr>
</thead>
<tbody><tr>
<td>操作系统加载用</td>
<td>链接器&#x2F;调试器用</td>
</tr>
<tr>
<td>每段可以包含多个节</td>
<td>更细粒度的代码&#x2F;数据划分</td>
</tr>
<tr>
<td>用于加载运行时内容</td>
<td>用于描述文件内容结构</td>
</tr>
<tr>
<td>段的对齐、权限等更重要</td>
<td>节名、调试、符号、重定位等更丰富</td>
</tr>
</tbody></table>
<h2 id="Smali汇编"><a href="#Smali汇编" class="headerlink" title="Smali汇编"></a>Smali汇编</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p> Smali基本数据类型中包含两种类型，原始类型和引用类型。对象类型和数组类型是引用类型，其它都是原始类型。具体数据类型如下表所示。</p>
<table>
<thead>
<tr>
<th><strong>Smali</strong></th>
<th><strong>Java</strong></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>v</td>
<td>void</td>
<td>只能用于返回值类型</td>
</tr>
<tr>
<td>Z</td>
<td>boolean</td>
<td>布尔类型</td>
</tr>
<tr>
<td>B</td>
<td>byte</td>
<td>字节类型</td>
</tr>
<tr>
<td>S</td>
<td>short</td>
<td>短整型</td>
</tr>
<tr>
<td>C</td>
<td>char</td>
<td>字符型</td>
</tr>
<tr>
<td>I</td>
<td>int</td>
<td>整数类型</td>
</tr>
<tr>
<td>J</td>
<td>long</td>
<td>长整型</td>
</tr>
<tr>
<td>F</td>
<td>float</td>
<td>浮点型数据类型</td>
</tr>
<tr>
<td>D</td>
<td>double</td>
<td>双精度浮点型</td>
</tr>
<tr>
<td>Lpackage&#x2F;name;</td>
<td>对象类型</td>
<td>L接完整的包名，使用“;”表示对象名称的结束</td>
</tr>
<tr>
<td>[数据类型</td>
<td>数组</td>
<td>[Ljava&#x2F;lang&#x2F;String，表示一个String类型的数组</td>
</tr>
</tbody></table>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.class + 权限修饰符 + 类名；</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">CharSequence</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.<span class="keyword">class</span> <span class="title class_">public</span> LTest;    #声明类（不可省略）</span><br><span class="line">.<span class="built_in">super</span> Ljava/lang/Object;    #声明该类所继承的父类，同Java，若没有指定其他父类，则所有类的父类都是Object（不可省略）</span><br><span class="line">.<span class="keyword">implements</span> <span class="title class_">Ljava</span>/lang/CharSequence;    #若该类实现了接口，则添加该代码（视情况可省略）</span><br><span class="line">.source <span class="string">&quot;Test.java&quot;</span>    #反编译的过程中自动生成的标识该smali类对应的java源码类的标识，无实际作用（可省略）</span><br></pre></td></tr></table></figure>

<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.method 权限修饰符+静态修饰符+方法名(参数类型)返回值类型</span><br><span class="line">    #方法体</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<p>示例1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getName</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.<span class="keyword">class</span> <span class="title class_">public</span> LTest;</span><br><span class="line">.<span class="built_in">super</span> Ljava/lang/Object;</span><br><span class="line">.source <span class="string">&quot;Test.java&quot;</span></span><br><span class="line"> </span><br><span class="line">.method <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">getName</span><span class="params">()</span>V</span><br><span class="line">    <span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<p>示例2(带返回值)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getName</span><span class="params">(String a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.<span class="keyword">class</span> <span class="title class_">public</span> LTest;</span><br><span class="line">.<span class="built_in">super</span> Ljava/lang/Object;</span><br><span class="line">.source <span class="string">&quot;Test.java&quot;</span></span><br><span class="line"> </span><br><span class="line">.method <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">getName</span><span class="params">(Ljava/lang/String;I)</span>Ljava/lang/String;</span><br><span class="line">    const-string v0, <span class="string">&quot;hello&quot;</span></span><br><span class="line">    <span class="keyword">return</span>-object v0</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<h3 id="函数返回关键字"><a href="#函数返回关键字" class="headerlink" title="函数返回关键字"></a>函数返回关键字</h3><table>
<thead>
<tr>
<th><strong>Smali方法返回关键字</strong></th>
<th><strong>J数据类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td>return</td>
<td>byte</td>
</tr>
<tr>
<td>return</td>
<td>short</td>
</tr>
<tr>
<td>return</td>
<td>int</td>
</tr>
<tr>
<td>return</td>
<td>float</td>
</tr>
<tr>
<td>return</td>
<td>char</td>
</tr>
<tr>
<td>return</td>
<td>boolean</td>
</tr>
<tr>
<td>return-wide</td>
<td>double</td>
</tr>
<tr>
<td>return-wide</td>
<td>long</td>
</tr>
<tr>
<td>return-void</td>
<td>void</td>
</tr>
<tr>
<td>return-object</td>
<td>array</td>
</tr>
<tr>
<td>return-object</td>
<td>object</td>
</tr>
<tr>
<td>smali中总共分为四种函数返回关键字，对于不同的数据类型，使用不同的函数返回关键字，long、double为64位数据类型，因此需要使用return-wide关键字，而其他基本数据类型为32位及以下，只需要使用return。对于空类型使用return-void。而对于大小未知的数组及object，则使用return-object。</td>
<td></td>
</tr>
</tbody></table>
<h3 id="构造函数声明"><a href="#构造函数声明" class="headerlink" title="构造函数声明"></a>构造函数声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.method+权限修饰符+constructor &lt;init&gt;(参数类型)返回值类型</span><br><span class="line">    #方法体</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(String a)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.<span class="keyword">class</span> <span class="title class_">public</span> LTest;</span><br><span class="line">.<span class="built_in">super</span> Ljava/lang/Object;</span><br><span class="line">.source <span class="string">&quot;Test.java&quot;</span></span><br><span class="line"> </span><br><span class="line">.method <span class="keyword">public</span> constructor &lt;init&gt;(Ljava/lang/String;)V</span><br><span class="line">    invoke-direct &#123;p0&#125;,Ljava/lang/Object;-&gt;&lt;init&gt;()V #调用父类（Object）的构造函数</span><br><span class="line">    <span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>


<p><code>构造函数的声明与普通函数声明的区别在于：1.必须加constructor修饰符；2.函数名必须为&lt;init&gt;；3.函数中必须调用父类的构造函数（java的构造函数中默认会调用父类的构造函数，但在代码中可以省略，而在Smali中不能省略）。</code></p>
<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.field 权限修饰符+静态修饰符+变量名：变量全类名路径;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.<span class="keyword">class</span> <span class="title class_">public</span> LTest;</span><br><span class="line">.<span class="built_in">super</span> Ljava/lang/Object;</span><br><span class="line">.source <span class="string">&quot;Test.java&quot;</span></span><br><span class="line"> </span><br><span class="line">.field <span class="keyword">private</span> <span class="keyword">static</span> a:Ljava/lang/String;    #声明一个String类的对象，命名为a</span><br></pre></td></tr></table></figure>

<h3 id="常量声明"><a href="#常量声明" class="headerlink" title="常量声明"></a>常量声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.field 权限修饰符+静态修饰符+<span class="keyword">final</span>+常量名：常量全类名路径;=常量值</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String a=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.<span class="keyword">class</span> <span class="title class_">public</span> LTest;</span><br><span class="line">.<span class="built_in">super</span> Ljava/lang/Object;</span><br><span class="line">.source <span class="string">&quot;Test.java&quot;</span></span><br><span class="line"> </span><br><span class="line">.field <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> a:Ljava/lang/String;=<span class="string">&quot;hello&quot;</span>    #声明一个String类的常量对象，命名为a，赋值为<span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.method+<span class="keyword">static</span>+constructor &lt;clinit&gt;()V</span><br><span class="line">    #方法体</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.<span class="keyword">class</span> <span class="title class_">public</span> LTest;</span><br><span class="line">.<span class="built_in">super</span> Ljava/lang/Object;</span><br><span class="line"> </span><br><span class="line">.method <span class="keyword">public</span> <span class="keyword">static</span> constructor&lt;clinit&gt;()V</span><br><span class="line">    <span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>


<p><code>静态代码块的声明同构造函数的声明的区别在于：1.增加了static修饰符；2.函数名改为了&lt;clinit&gt;；3.无参数；4.返回类型固定为void</code></p>
<p>Smali静态字段声明位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String a=<span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.<span class="keyword">class</span> <span class="title class_">public</span> LTest;</span><br><span class="line">.<span class="built_in">super</span> Ljava/lang/Object;</span><br><span class="line"> </span><br><span class="line">.method <span class="keyword">public</span> <span class="keyword">static</span> constructor&lt;clinit&gt;()V</span><br><span class="line">    .field <span class="keyword">public</span> <span class="keyword">static</span> a:Ljava/lang/String;=<span class="string">&quot;a&quot;</span></span><br><span class="line">    <span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<p><code>当类中声明了静态的字段时，该字段的声明必须于静态代码块中进行，因该字段属于类而非对象，且静态代码块在构造函数之前被执行。</code></p>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">invoke-virtual    #非私有实例函数的调用</span><br><span class="line">invoke-direct    #构造函数以及私有函数的调用</span><br><span class="line">invoke-<span class="keyword">static</span>    #静态函数的调用</span><br><span class="line">invoke-<span class="built_in">super</span>    #父类函数的调用</span><br><span class="line">invoke-interface    #接口函数的调用</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(String a)</span>&#123;</span><br><span class="line">        getName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.<span class="keyword">class</span> <span class="title class_">public</span> LTest;</span><br><span class="line">.<span class="built_in">super</span> Ljava/lang/Object;</span><br><span class="line"> </span><br><span class="line">.method <span class="keyword">public</span> constructor&lt;init&gt;(Ljava/lang/String;)V</span><br><span class="line">    invoke-direct&#123;p0&#125;,Ljava/lang/Object;-&gt;&lt;init&gt;()V    #调用父类的构造函数</span><br><span class="line">    invoke-virtual&#123;p0&#125;,LTest;-&gt;getName()Ljava/lang/String;    #调用普通成员getName函数</span><br><span class="line">    <span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">.end method</span><br><span class="line"> </span><br><span class="line">.method <span class="keyword">public</span> <span class="title function_">getName</span><span class="params">()</span>Ljava/lang/String;</span><br><span class="line">    const-string v0,<span class="string">&quot;hello&quot;</span>    #定义局部字符串常量</span><br><span class="line">    <span class="keyword">return</span>-object v0    #返回常量</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<p><code>以上代码段中定义的getName函数是没有参数的，但是在调用该函数时却传入了一个参数p0，该p0参数实质上为类的对象，即java中的this。因被调用的getName函数非静态函数，因此在使用该函数时必须传入一个this作为参数，而这一步在java中被默认执行，故书写代码时常被省略。</code></p>
<p>示例：构造函数以及私有实例函数的调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-direct &#123;参数&#125;,函数所属类名;-&gt;函数名(参数类型)返回值类型;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(String a)</span>&#123;</span><br><span class="line">        getName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.<span class="keyword">class</span> <span class="title class_">public</span> LTest;</span><br><span class="line">.<span class="built_in">super</span> Ljava/lang/Object;</span><br><span class="line"> </span><br><span class="line">.method <span class="keyword">public</span> constructor&lt;init&gt;(Ljava/lang/String;)V</span><br><span class="line">    invoke-direct&#123;p0&#125;,Ljava/lang/Object;-&gt;&lt;init&gt;()V    #调用父类的构造函数</span><br><span class="line">    invoke-direct&#123;p0&#125;,LTest;-&gt;getName()Ljava/lang/String;    #调用私有成员getName函数</span><br><span class="line">    <span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">.end method</span><br><span class="line"> </span><br><span class="line">.method <span class="keyword">private</span> <span class="title function_">getName</span><span class="params">()</span>Ljava/lang/String;</span><br><span class="line">    const-string v0,<span class="string">&quot;hello&quot;</span>    #定义局部字符串常量</span><br><span class="line">    <span class="keyword">return</span>-object v0    #返回常量</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<p>示例：静态函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-<span class="keyword">static</span> &#123;参数&#125;,函数所属类名;-&gt;函数名(参数类型)返回值类型;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(String a)</span>&#123;</span><br><span class="line">        String b=getName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.<span class="keyword">class</span> <span class="title class_">public</span> LTest;</span><br><span class="line">.<span class="built_in">super</span> Ljava/lang/Object;</span><br><span class="line"> </span><br><span class="line">.method <span class="keyword">public</span> constructor&lt;init&gt;(Ljava/lang/String;)V</span><br><span class="line">    invoke-direct&#123;p0&#125;,Ljava/lang/Object;-&gt;&lt;init&gt;()V    #调用父类的构造函数</span><br><span class="line">    invoke-<span class="keyword">static</span>&#123;&#125;,LTest;-&gt;getName()Ljava/lang/String;    #调用私有成员getName函数</span><br><span class="line">    move-result-object v0    #将返回值赋给v0</span><br><span class="line">    <span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">.end method</span><br><span class="line"> </span><br><span class="line">.method <span class="keyword">private</span> <span class="title function_">getName</span><span class="params">()</span>Ljava/lang/String;</span><br><span class="line">    const-string v0,<span class="string">&quot;hello&quot;</span>    #定义局部字符串常量</span><br><span class="line">    <span class="keyword">return</span>-object v0    #返回常量</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<p>示例： 父类成员函数的调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-<span class="built_in">super</span> &#123;参数&#125;,函数所属类名;-&gt;函数名(参数类型)返回值类型;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.method <span class="keyword">protected</span> <span class="title function_">onCreate</span><span class="params">(Landroid/os/Bundle;)</span>V</span><br><span class="line">    .registers <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    invoke-<span class="built_in">super</span>&#123;p0,p1&#125;,Landroid/app/Activity;-&gt;onCreate(Landroid/os/Bundle;)V</span><br><span class="line">    <span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<p>示例： 接口函数调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-interface &#123;参数&#125;,函数所属类名;-&gt;函数名(参数类型)返回值类型;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> InterTest a=<span class="keyword">new</span> <span class="title class_">Test2</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(String a)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAa</span><span class="params">()</span>&#123;</span><br><span class="line">        InterTest aa=a;</span><br><span class="line">        <span class="comment">//调用接口方法</span></span><br><span class="line">        aa.est2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> <span class="keyword">implements</span> <span class="title class_">InterTest</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Test2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">est2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">InterTest</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">est2</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.method <span class="keyword">public</span> <span class="title function_">setAa</span><span class="params">()</span>V</span><br><span class="line">    .registers <span class="number">2</span></span><br><span class="line">    iget-object v0,p0,LTest;-&gt;a:LTest$InterTest;</span><br><span class="line">    #调用接口方法</span><br><span class="line">    invoke-interface&#123;v0&#125;,LTest$InterTest;-&gt;est2()V</span><br><span class="line">    <span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<h3 id="字段取值与赋值"><a href="#字段取值与赋值" class="headerlink" title="字段取值与赋值"></a>字段取值与赋值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iput 存储值的寄存器,对象全类名路径-&gt;字段名:字段类型全类名路径    #静态字段</span><br><span class="line">iput 存储值的寄存器,存储字段的对象,对象全类名路径-&gt;字段名:字段类型全类名路径    #字段</span><br><span class="line">iget 存储值的寄存器,对象全类名路径-&gt;字段名:字段类型全类名路径    #静态字段</span><br><span class="line">iget 存储值的寄存器,对象全类名路径-&gt;字段名:字段类型全类名路径    #字段</span><br></pre></td></tr></table></figure>

<p>Smali基本数据类型取值赋值关键字表</p>
<img src="/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250416210943736.png" class="">

<p>Smali实例变量取值赋值关键字表</p>
<img src="/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250416210954339.png" class="">

<p>smali——java取值赋值对照</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>  String a=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(String a)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getA</span><span class="params">()</span>&#123;</span><br><span class="line">       String aa=a;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.<span class="keyword">class</span> <span class="title class_">public</span> LTest;#声明类 （必须）</span><br><span class="line">.<span class="built_in">super</span> Ljava/lang/Object;#声明父类 默认继承Object （必须）</span><br><span class="line">.source <span class="string">&quot;Test.java&quot;</span> # 源码文件 （非必须）</span><br><span class="line"> </span><br><span class="line"># 声明静态字段</span><br><span class="line">.field <span class="keyword">private</span> <span class="keyword">static</span> a:Ljava/lang/String;</span><br><span class="line"> </span><br><span class="line">#构造方法</span><br><span class="line">.method <span class="keyword">public</span> constructor &lt;init&gt;(Ljava/lang/String;)V</span><br><span class="line">    .registers <span class="number">3</span></span><br><span class="line"> </span><br><span class="line">    .prologue</span><br><span class="line"> </span><br><span class="line">    invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V</span><br><span class="line"> </span><br><span class="line">    const-string v0, <span class="string">&quot;hello&quot;</span></span><br><span class="line">	# 初始化成员变量</span><br><span class="line">    iput-object v0, LTest;-&gt;a:Ljava/lang/String;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">.end method</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 取值方法</span><br><span class="line">.method <span class="keyword">public</span> <span class="title function_">getA</span><span class="params">()</span>Ljava/lang/String;</span><br><span class="line">    .registers <span class="number">2</span></span><br><span class="line"> </span><br><span class="line">	# 类非静态字段取值</span><br><span class="line">    iget-object v0, LTest;-&gt;a:Ljava/lang/String;</span><br><span class="line">    <span class="keyword">return</span>-object v0</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<h3 id="Smali数组的取值与赋值"><a href="#Smali数组的取值与赋值" class="headerlink" title="Smali数组的取值与赋值"></a>Smali数组的取值与赋值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aput 存储值的寄存器,存储数组的寄存器,存储数组下标的寄存器</span><br><span class="line">aget 存储值的寄存器,存储数组的寄存器,存储数组下标的寄存器</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">invoke-virtual &#123;v1, v0&#125;, Ljava/security/MessageDigest;-&gt;digest([B)[B</span><br><span class="line">move-result-object v0</span><br><span class="line">const/<span class="number">16</span> v4,<span class="number">47</span></span><br><span class="line">const/<span class="number">16</span> v5,<span class="number">0</span></span><br><span class="line">aput-<span class="type">byte</span> v4,v0,v5</span><br><span class="line">aget-<span class="type">byte</span> v3,v0,v5</span><br></pre></td></tr></table></figure>

<p>这里解释下这段汇编</p>
<p><strong><code>invoke-virtual &#123;v1, v0&#125;, Ljava/security/MessageDigest;-&gt;digest([B)[B</code></strong></p>
<ul>
<li><p>调用 Java 的 <code>MessageDigest.digest(byte[] input)</code> 方法。</p>
</li>
<li><p><code>v1</code>：<code>MessageDigest</code> 实例（如 <code>SHA-256</code>）</p>
</li>
<li><p><code>v0</code>：原始输入的 <code>byte[]</code></p>
</li>
<li><p>返回值是 <code>byte[]</code> 类型，存储计算后的哈希值。</p>
</li>
<li><p> <strong><code>move-result-object v0</code></strong></p>
</li>
<li><p>接收上一步调用返回的哈希结果，赋值给 <code>v0</code>。</p>
</li>
<li><p>此时，<code>v0</code> 成为了 digest 输出的 <code>byte[]</code>。</p>
</li>
</ul>
<p><strong><code>const/16 v4, 47</code></strong></p>
<ul>
<li>将整数常量 <code>47</code> 加载到 <code>v4</code> 中。</li>
<li>十进制 <code>47</code> &#x3D; 十六进制 <code>0x2F</code>，等于 ASCII 字符 <code>&#39;/&#39;</code>。</li>
</ul>
<p><strong><code>const/16 v5, 0</code></strong></p>
<ul>
<li>将索引值 <code>0</code> 加载到 <code>v5</code> 中，用于访问 <code>v0</code> 数组的第一个元素</li>
</ul>
<p><strong><code>aput-byte v4, v0, v5</code></strong></p>
<ul>
<li>将 <code>v4</code>（即 <code>47</code>）这个字节写入到 <code>v0[0]</code> 中。</li>
<li>相当于强行篡改哈希结果的首字节：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v0[<span class="number">0</span>] = <span class="number">47</span>;</span><br></pre></td></tr></table></figure>

<p><strong><code>aget-byte v3, v0, v5</code></strong></p>
<ul>
<li>从 <code>v0[0]</code> 读取一个字节，赋值到 <code>v3</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v3 = v0[<span class="number">0</span>]; <span class="comment">// 此时 v3 = 47</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Smali对象创建"><a href="#Smali对象创建" class="headerlink" title="Smali对象创建"></a>Smali对象创建</h3><p>定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>-instance+对象名,对象全包名路径;    #声明实例</span><br><span class="line">invoke-direct&#123;变量名&#125;,对象全包名路径;-&gt;&lt;init&gt;(参数)返回类型    #调用构造函数（若构造函数内还定义了成员变量，则在调用之前需要提前声明该变量并在invoke时作为参数一并传入）</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test _test=<span class="keyword">new</span> <span class="title class_">Test</span>();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>-instance v0,LTest;</span><br><span class="line">invoke-direct &#123;v0&#125;,LTest;-&gt;&lt;init&gt;()V</span><br></pre></td></tr></table></figure>

<h3 id="Smali常量数据定义"><a href="#Smali常量数据定义" class="headerlink" title="Smali常量数据定义"></a>Smali常量数据定义</h3><p><strong>定义：</strong> 在Smali语言中，函数返回或函数调用等处若需使用常量，应当如同使用变量一般先行将之定义并存入寄存器中，后方可使用。</p>
<h4 id="Smali字符串常量定义"><a href="#Smali字符串常量定义" class="headerlink" title="Smali字符串常量定义"></a>Smali字符串常量定义</h4><p>定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const-string 常量名,&quot;字符串内容&quot;</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.<span class="keyword">class</span> <span class="title class_">public</span> LTest;</span><br><span class="line">.<span class="built_in">super</span> Ljava/lang/Object;</span><br><span class="line"> </span><br><span class="line">.method <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">getHello</span><span class="params">()</span>Ljava/lang/String;</span><br><span class="line">    .registers <span class="number">1</span>    #该函数总共使用了<span class="number">1</span>个寄存器</span><br><span class="line">    const-string v0,<span class="string">&quot;hello&quot;</span>    #定义字符串常量</span><br><span class="line">    <span class="keyword">return</span>-object v0    #将字符串常量作为返回值</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<p>如上代码段所示，定义一个”hello”字符串存入寄存器，命名为v0，并将之作为返回值返回（因字符串为Object类型的数据，因此使用return-object）</p>
<h4 id="Smali字节码常量定义"><a href="#Smali字节码常量定义" class="headerlink" title="Smali字节码常量定义"></a>Smali字节码常量定义</h4><p>定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const-class 常量名,类全包名路径;</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class a=TestClass.class</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const-<span class="keyword">class</span> <span class="title class_">v0</span>,LTestClass;</span><br></pre></td></tr></table></figure>

<h4 id="Smali数值常量定义"><a href="#Smali数值常量定义" class="headerlink" title="Smali数值常量定义"></a>Smali数值常量定义</h4><p>格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const 寄存器,数值 #占用一个寄存器（32位）</span><br><span class="line">    const/4    #占用一个寄存器中的低4位（最高位为符号位）</span><br><span class="line">    const/16    #占用一个寄存器中的低16位（最高位为符号位）</span><br><span class="line">    const    #占用一个寄存器中全部32位（最高位为符号位）</span><br><span class="line">    const/high16    #占用一个寄存器中的16位,且只将数据的高16位存入（最高位为符号位）</span><br><span class="line">const-wide 寄存器,数值 #占用两个寄存器（64位）</span><br><span class="line">    const-wide/16    #占用两个寄存器的同时只使用第一个寄存器的低16位</span><br><span class="line">    const-wide/32    #占用两个寄存器的同时只使用第一个寄存器的32位</span><br><span class="line">    const-wide    #占用两个寄存器的同时只使用两个寄存器的全部64位</span><br><span class="line">    const-wide/high16    #占用两个寄存器的同时只使用第一个寄存器的16位,且只将数据的高16位存入</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">100</span>;</span><br><span class="line"><span class="type">long</span> j=<span class="number">10000</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const/<span class="number">16</span> v0,<span class="number">64</span>   </span><br><span class="line">const-wide v1,<span class="number">2710</span></span><br></pre></td></tr></table></figure>

<h3 id="Smali条件跳转"><a href="#Smali条件跳转" class="headerlink" title="Smali条件跳转"></a>Smali条件跳转</h3><p>定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>-eq vA, vB, :cond_**  #如果vA等于vB则跳转到:cond_** equal</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>-ne vA, vB, :cond_**  #如果vA不等于vB则跳转到:cond_**   not  equal</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>-lt vA, vB, :cond_**  #如果vA小于vB则跳转到:cond_**    less than</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>-ge vA, vB, :cond_**  #如果vA大于等于vB则跳转到:cond_**   greater equal</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>-gt vA, vB, :cond_**  #如果vA大于vB则跳转到:cond_**   greater than</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>-le vA, vB, :cond_**  #如果vA小于等于vB则跳转到:cond_**  less equal</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>-eqz vA, :cond_**  #如果vA等于<span class="number">0</span>则跳转到:cond_** zero</span><br><span class="line"><span class="keyword">if</span>-nez vA, :cond_**  #如果vA不等于<span class="number">0</span>则跳转到:cond_**</span><br><span class="line"><span class="keyword">if</span>-ltz vA, :cond_**  #如果vA小于<span class="number">0</span>则跳转到:cond_**</span><br><span class="line"><span class="keyword">if</span>-gez vA, :cond_**  #如果vA大于等于<span class="number">0</span>则跳转到:cond_**</span><br><span class="line"><span class="keyword">if</span>-gtz vA, :cond_**  #如果vA大于<span class="number">0</span>则跳转到:cond_**</span><br><span class="line"><span class="keyword">if</span>-lez vA, :cond_**  #如果vA小于等于<span class="number">0</span>则跳转到:cond_**</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//do-something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.method <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">main</span><span class="params">([Ljava/lang/String;)</span>V</span><br><span class="line"> </span><br><span class="line">    const/<span class="number">16</span> v0,<span class="number">0x2</span></span><br><span class="line">    const/<span class="number">4</span> v1, <span class="number">0x1</span></span><br><span class="line">    <span class="keyword">if</span>-le v0,v1,:cond_0</span><br><span class="line">        #<span class="keyword">do</span>-something</span><br><span class="line">    :cond_0</span><br><span class="line">    <span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<h3 id="Smali逻辑循环"><a href="#Smali逻辑循环" class="headerlink" title="Smali逻辑循环"></a>Smali逻辑循环</h3><p>定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> :cond_**  #跳转到:cond_**</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.method <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">main</span><span class="params">([Ljava/lang/String;)</span>V</span><br><span class="line"> </span><br><span class="line">    const/<span class="number">4</span> v0, <span class="number">0x0</span></span><br><span class="line"> </span><br><span class="line">    :goto_1</span><br><span class="line">    const/<span class="number">4</span> v1, <span class="number">0x3</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>-ge v0, v1, :cond_7</span><br><span class="line"> </span><br><span class="line">    add-<span class="type">int</span>/lit8 v0, v0, <span class="number">0x1</span> # 加法运算符 v0=v0+<span class="number">0x1</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">goto</span> :goto_1</span><br><span class="line"> </span><br><span class="line">    :cond_7</span><br><span class="line">    <span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>寄存器分为如下两类：<br>1、本地寄存器<br>用v开头数字结尾的符号来表示，v0, v1, v2,…<br>2、参数寄存器<br>用p开头数字结尾的符号来表示，p0,p1,p2,…<br>注意：<br>在非static方法中，p0代指this，p1为方法的第一个参数。<br>在static方法中，p0为方法的第一个参数。</p>
<h2 id="ARM汇编"><a href="#ARM汇编" class="headerlink" title="ARM汇编"></a>ARM汇编</h2><p>具体参考： <a target="_blank" rel="noopener" href="https://blog.csdn.net/Luckiers/article/details/128221506">https://blog.csdn.net/Luckiers/article/details/128221506</a></p>
<h3 id="寄存器详解"><a href="#寄存器详解" class="headerlink" title="寄存器详解"></a>寄存器详解</h3><h5 id="1-通用寄存器"><a href="#1-通用寄存器" class="headerlink" title="1. 通用寄存器"></a>1. 通用寄存器</h5><p>通用寄存器是一组用于存储数据和地址的寄存器。在 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=ARM%20%E6%9E%B6%E6%9E%84&spm=1001.2101.3001.7020">ARM 架构</a>的不同版本中，这些寄存器的数量和命名有所不同。<br>R0-R15 (R0-R14 + PC):<br>在 ARMv7 和之前的版本中，有 16 个通用寄存器，编号从 R0 到 R15。<br>R0 到 R14 用于存储数据和地址。<br>R15 通常被称为程序计数器（PC），用于存储下一条指令的地址。</p>
<p>X0-X30 (X0-X28+ FR + LR):<br>在 ARMv8 和之后的版本中，有 31 个通用寄存器，编号从 X0 到 X30。<br>X0 到 X28 用于存储数据和地址。<br>X29： Frame Pointer (FP) 寄存器,它的主要作用是指向当前函数的栈帧(Stack Frame)<br>X30: 链接寄存器（LR），用于保存返回地址。</p>
<p>在ARMv7架构中使用程序状态寄存器(Current Program Status Register,CPSR)来表示当前的处理器状态(processor stste),而在ARMv8里使用PSTATE寄存器来表示。</p>
<p><strong>ARMv8及以后版本：</strong></p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>位数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>X0-X30</td>
<td>64bit</td>
<td>通用寄存器，如果有需要可以当作32bit使用：W0-W30</td>
</tr>
<tr>
<td>FP(X29)</td>
<td>64bit</td>
<td>保存栈帧地址(栈底指针)</td>
</tr>
<tr>
<td>LR(X30)</td>
<td>64bit</td>
<td>程序链接寄存器，保存子程序结束后需要执行的下一条指令</td>
</tr>
<tr>
<td>SP</td>
<td>64bit</td>
<td>保存栈顶指针，使用SP&#x2F;WSP来进行对SP寄存器的访问。</td>
</tr>
<tr>
<td>PC</td>
<td>64bit</td>
<td>程序计数器，俗称PC指针，总是指向即将要执行的下一条指令，在arm64中，软件不能修改PC寄存器</td>
</tr>
<tr>
<td>PSTATE</td>
<td>64bit</td>
<td>状态寄存器，用于保存处理器的当前状态信息。</td>
</tr>
</tbody></table>
<p>ARM 64包含31个64bit寄存器，记为X0<del>X30。<br>每一个通用寄存器，它的低32bit都可以被访问，记为W0</del>W30。</p>
<p>LDR和STR分别从地址中读入内容到寄存器和向地址中写入寄存器的内容，后缀B表示字节，H表示半字，W表示单字</p>
<p>向量和浮点寄存器。32个寄存器，向量和浮点共用，每个128位，用V0到V31来表示。不同的记号可以表示不同的长度，B表示字节，H表示半字，S表示单字，D表示双字，Q表示四字<br><img src="/c00b8f3c09582f980182c47c971dc7bc_MD5.webp"></p>
<p>X0 - X7： 这8个寄存器通常用作函数参数寄存器，在函数调用时用来传递前8个参数，若参数个数大于8，就采用栈来传递。64位的函数返回值通常存放在X0寄存器中，128位的返回结果存在X0和X1两个寄存器中。<br>X8： 间接结果位置寄存器，用于保存子函数的返回地址。在一些情况下，X8可以用于普通的临时寄存器，用于存储中间计算结果。<br>X9 - X15： 通常被用作临时变量和中间计算结果的存储。调用者有责任在函数调用前保存它们的值,以免被覆盖。函数返回后,调用者也需要恢复这些寄存器的值。<br>X16、X17： X16 (IP0, Intra-Procedure-call scratch register 0)这个寄存器通常被用作临时寄存器,用于存储函数内部的中间计算结果。它在函数调用过程中可能会被修改,所以调用者需要自行保存和恢复。X17与X16类似。</p>
<p>X18： X18 (Platform register)这个寄存器通常被用作平台相关的寄存器,其用途取决于具体的硬件平台和软件环境。在某些系统中,X18 可能被用作过程链接表(PLT)指针,用于动态链接。在其他系统中,X18 可能被用作线程局部存储(Thread Local Storage)的指针。<br>X19 - X28： 通常用于存储函数的局部变量和中间计算结果。被调用的函数有责任在返回前保存和恢复这些寄存器的值,确保调用者可以继续使用。</p>
<p>X29： Frame Pointer (FP) 寄存器,它的主要作用是指向当前函数的栈帧(Stack Frame),方便访问函数内部的局部变量和参数。当一个函数被调用时,x29 寄存器会被设置为指向该函数的栈帧起始地址。这样可以通过 x29 寄存器轻松访问函数内部的局部变量和参数,而不需要依赖 x30 寄存器(Link Register)中存储的返回地址。</p>
<p>X30: Link Register (LR),它的主要作用是在函数调用时存储函数的返回地址,以便函数执行完毕后能够正确地返回到调用点。当一个函数被调用时,CPU 会将当前执行点的地址保存到 x30 寄存器中。这样在函数执行完毕后,只需要从 x30 寄存器中恢复返回地址,就可以正确地返回到调用点。注意：当一个函数被调用时,CPU 会自动将当前执行点的地址(也就是函数调用语句的下一条指令地址)保存到 x30 寄存器中。</p>
<p>X9 - X15和X19 - X28这两组寄存器的区别:</p>
<p>x9 到 x15 则主要用作临时变量和中间计算结果的存储。x19 到 x28 通常用作函数的局部变量和中间计算结果的存储。对于 x9 到 x15 这些”caller-saved”寄存器,调用者(caller)有责任在函数调用前保存它们的值,并在调用后恢复。对于 x19 到 x28 这些”callee-saved”寄存器,被调用的函数(callee)有责任在返回前保存和恢复它们的值。使用”callee-saved”寄存器通常可以减少对栈的访问,提高性能。但同时也增加了函数调用时保存和恢复寄存器的开销。</p>
<p><strong>ARMv8前版本：</strong><br>R0-R15寄存器 根据“ARM-thumb 过程调用标准”：<br>R0-R3 其中，R0通常用于存储函数的返回值，R1-R3则常用于传递函数参数。在子程序调用之前，可以将R0-R3用于任何用途。被调用函数在返回之前不必恢复R0-R3。如果调用函数需要再次使用 r0-r3的内容，则它必须保留这些内容。<br>R4-R11 被用来存放函数的局部变量。如果被调用函数使用了这些寄存器，它在返回之前必须恢复这些寄存器的值。<br>R12是内部调用暂时寄存器IP。它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色。<br>在过程调用之间，可以将它用于任何用途。被调用函数在返回之前不必恢复R12。<br>R13是栈指针SP：<br>在ARM指令集中，R13常被用作堆栈指针，用于存储程序中的局部变量和函数调用时的返回地址。它不能用于任何其它用途。SP中存放的值在退出被调用函数时必须与进入时的值相同。用户也可以使用其他寄存器作为堆栈指针，但在Thumb指令集中，某些指令强制要求使用R13作为堆栈指针。<br>R14是链接寄存器LR：<br>用于存储函数调用之前的返回地址，如果您保存了返回地址，则可以在调用之前将R14用于其它用途，程序返回时要恢复。当执行子程序调用指令（如BL或BLX）时，R14会被设置成该子程序的返回地址。在子程序返回时，将R14的值复制回程序计数器PC即可完成子程序的调用返回。<br>R15是程序计数器PC：<br>用于存储当前正在执行的指令的地址。程序计数器是处理器控制指令执行的关键寄存器之一。它不能用于任何其它用途。由于ARM采用了流水线机制，当正确读取了PC的值后，该值为当前指令地址加8个字节，即PC指向当前指令的下两条指令地址。<br>注意：在中断程序中，所有的寄存器都必须保护，编译器会自动保护R4～R11。</p>
<h5 id="2-专用寄存器"><a href="#2-专用寄存器" class="headerlink" title="2. 专用寄存器"></a>2. 专用寄存器</h5><p>ARM处理器中的专用寄存器主要包括程序状态寄存器（CPSR）和备份的程序状态寄存器（SPSRs）。<br>程序状态寄存器（CPSR）</p>
<p>CPSR是一个32位的特殊寄存器，用于存储当前程序的状态信息。它包含以下内容：</p>
<p>ALU状态标志 ：如条件码（如零标志Z、负标志N、进位标志C等），用于反映ALU的运算结果。<br>中断使能位 ：用于控制中断的使能状态。<br>执行模式位 ：用于标识当前处理器的执行模式（如用户模式、系统模式、中断模式等）。</p>
<p>CPSR和SPSR都是程序状态寄存器，其中SPSR是用来保存中断前的CPSR中的值，以便在中断返回之后恢复处理器程序状态。<br>CPSR在任何处理器模式下都可被访问和修改（但某些位可能需要特权级代码才能修改）。通过读取和修改CPSR寄存器的各个标志位和控制位，可以控制程序的执行流程和处理器的行为。<br>备份的程序状态寄存器（SPSRs）</p>
<p>ARM处理器还包含5个备份的程序状态寄存器（SPSR_fiq、SPSR_irq、SPSR_svc、SPSR_abt、SPSR_und），用于在异常处理期间保存CPSR的值。当处理器进入异常模式时，会将CPSR的内容复制到对应的SPSR中；当从异常模式返回时，则可以将SPSR的内容复制回CPSR以恢复处理器的状态。</p>
<h5 id="3-控制寄存器"><a href="#3-控制寄存器" class="headerlink" title="3. 控制寄存器"></a>3. 控制寄存器</h5><p>虽然控制寄存器不直接归类为通用或专用寄存器，但它们在ARM处理器的控制中发挥着重要作用。这些寄存器通常包含处理器的控制位和配置位，用于控制处理器的行为和工作模式。由于控制寄存器的访问和修改通常需要特权级代码，因此它们在普通的应用程序中很少被直接访问。如控制CPU的行为，如 CTRL 和 ACTLR。</p>
<h4 id="2-1-32位数据操作指令"><a href="#2-1-32位数据操作指令" class="headerlink" title="2.1 32位数据操作指令"></a>2.1 32位数据操作指令</h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>名字</td>
<td>功能</td>
</tr>
<tr>
<td>ADC</td>
<td>带进位加法</td>
</tr>
<tr>
<td>ADD</td>
<td>加法</td>
</tr>
<tr>
<td>ADDW</td>
<td>宽加法（可以加 12 位立即数）</td>
</tr>
<tr>
<td>AND</td>
<td>按位与</td>
</tr>
<tr>
<td>ASR</td>
<td>算术右移</td>
</tr>
<tr>
<td>BIC</td>
<td>位清零（把一个数按位取反后，与另一个数逻辑与）</td>
</tr>
<tr>
<td>BFC</td>
<td>位段清零</td>
</tr>
<tr>
<td>BFI</td>
<td>位段插入</td>
</tr>
<tr>
<td>CMN</td>
<td>负向比较（把一个数和另一个数的二进制补码比较，并更新标志位）</td>
</tr>
<tr>
<td>CMP</td>
<td>比较两个数并更新标志位</td>
</tr>
<tr>
<td>CLZ</td>
<td>计算前导零的数目</td>
</tr>
<tr>
<td>EOR</td>
<td>按位异或</td>
</tr>
<tr>
<td>LSL</td>
<td>逻辑左移</td>
</tr>
<tr>
<td>LSR</td>
<td>逻辑右移</td>
</tr>
<tr>
<td>MLA</td>
<td>乘加</td>
</tr>
<tr>
<td>MLS</td>
<td>乘减</td>
</tr>
<tr>
<td>MOVW</td>
<td>把 16 位立即数放到寄存器的底16位，高16位清0</td>
</tr>
<tr>
<td>MOV</td>
<td>加载16位立即数到寄存器（其实汇编器会产生MOVW——译注）</td>
</tr>
<tr>
<td>MOVT</td>
<td>把 16 位立即数放到寄存器的高16位，低 16位不影响</td>
</tr>
<tr>
<td>MVN</td>
<td>移动一个数的补码</td>
</tr>
<tr>
<td>MUL</td>
<td>乘法</td>
</tr>
<tr>
<td>ORR</td>
<td>按位或</td>
</tr>
<tr>
<td>ORN</td>
<td>把源操作数按位取反后，再执行按位或（</td>
</tr>
<tr>
<td>RBIT</td>
<td>位反转（把一个 32 位整数先用2 进制表达，再旋转180度——译注）</td>
</tr>
<tr>
<td>REV</td>
<td>对一个32 位整数做按字节反转</td>
</tr>
<tr>
<td>REVH&#x2F;REV16</td>
<td>对一个32 位整数的高低半字都执行字节反转</td>
</tr>
<tr>
<td>REVSH</td>
<td>对一个32 位整数的低半字执行字节反转，再带符号扩展成32位数</td>
</tr>
<tr>
<td>ROR</td>
<td>圆圈右移</td>
</tr>
<tr>
<td>RRX</td>
<td>带进位的逻辑右移一格（最高位用C 填充，且不影响C的值——译注）</td>
</tr>
<tr>
<td>SFBX</td>
<td>从一个32 位整数中提取任意的位段，并且带符号扩展成 32 位整数</td>
</tr>
<tr>
<td>SDIV</td>
<td>带符号除法</td>
</tr>
<tr>
<td>SMLAL</td>
<td>带符号长乘加（两个带符号的 32 位整数相乘得到 64 位的带符号积，再把积加到另一个带符号 64位整数中）</td>
</tr>
<tr>
<td>SMULL</td>
<td>带符号长乘法（两个带符号的 32 位整数相乘得到 64位的带符号积）</td>
</tr>
<tr>
<td>SSAT</td>
<td>带符号的饱和运算</td>
</tr>
<tr>
<td>SBC</td>
<td>带借位的减法</td>
</tr>
<tr>
<td>SUB</td>
<td>减法</td>
</tr>
<tr>
<td>SUBW</td>
<td>宽减法，可以减 12 位立即数</td>
</tr>
<tr>
<td>SXTB</td>
<td>字节带符号扩展到32位数</td>
</tr>
<tr>
<td>TEQ</td>
<td>测试是否相等（对两个数执行异或，更新标志但不存储结果）</td>
</tr>
<tr>
<td>TST</td>
<td>测试（对两个数执行按位与，更新标志但不存储结果）</td>
</tr>
<tr>
<td>UBFX</td>
<td>无符号位段提取</td>
</tr>
<tr>
<td>UDIV</td>
<td>无符号除法</td>
</tr>
<tr>
<td>UMLAL</td>
<td>无符号长乘加（两个无符号的 32 位整数相乘得到 64 位的无符号积，再把积加到另一个无符号 64位整数中）</td>
</tr>
<tr>
<td>UMULL</td>
<td>无符号长乘法（两个无符号的 32 位整数相乘得到 64位的无符号积）</td>
</tr>
<tr>
<td>USAT</td>
<td>无符号饱和操作（但是源操作数是带符号的——译注）</td>
</tr>
<tr>
<td>UXTB</td>
<td>字节被无符号扩展到32 位（高24位清0——译注）</td>
</tr>
<tr>
<td>UXTH</td>
<td>半字被无符号扩展到32 位（高16位清0——译注）</td>
</tr>
</tbody></table>
<h4 id="2-2-32位存储器数据传送指令"><a href="#2-2-32位存储器数据传送指令" class="headerlink" title="2.2 32位存储器数据传送指令"></a>2.2 32位存储器数据传送指令</h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>名字</td>
<td>功能</td>
</tr>
<tr>
<td>LDR</td>
<td>加载字到寄存器</td>
</tr>
<tr>
<td>LDRB</td>
<td>加载字节到寄存器</td>
</tr>
<tr>
<td>LDRH</td>
<td>加载半字到寄存器</td>
</tr>
<tr>
<td>LDRSH</td>
<td>加载半字到寄存器，再带符号扩展到 32位</td>
</tr>
<tr>
<td>LDM</td>
<td>从一片连续的地址空间中加载多个字到若干寄存器</td>
</tr>
<tr>
<td>LDRD</td>
<td>从连续的地址空间加载双字（64 位整数）到2 个寄存器</td>
</tr>
<tr>
<td>STR</td>
<td>存储寄存器中的字</td>
</tr>
<tr>
<td>STRB</td>
<td>存储寄存器中的低字节</td>
</tr>
<tr>
<td>STRH</td>
<td>存储寄存器中的低半字</td>
</tr>
<tr>
<td>STM</td>
<td>存储若干寄存器中的字到一片连续的地址空间中</td>
</tr>
<tr>
<td>STRD</td>
<td>存储2 个寄存器组成的双字到连续的地址空间中</td>
</tr>
<tr>
<td>PUSH</td>
<td>把若干寄存器的值压入堆栈中</td>
</tr>
<tr>
<td>POP</td>
<td>从堆栈中弹出若干的寄存器的值</td>
</tr>
</tbody></table>
<h4 id="2-3-32位转移指令"><a href="#2-3-32位转移指令" class="headerlink" title="2.3 32位转移指令"></a>2.3 32位转移指令</h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>名字</td>
<td>功能</td>
</tr>
<tr>
<td>B</td>
<td>无条件转移</td>
</tr>
<tr>
<td>BL</td>
<td>转移并连接（呼叫子程序）</td>
</tr>
<tr>
<td>TBB</td>
<td>以字节为单位的查表转移。从一个字节数组中选一个8位前向跳转地址并转移</td>
</tr>
<tr>
<td>TBH</td>
<td>以半字为单位的查表转移。从一个半字数组中选一个16 位前向跳转的地址并转移</td>
</tr>
</tbody></table>
<h4 id="2-4-其它32位指令"><a href="#2-4-其它32位指令" class="headerlink" title="2.4 其它32位指令"></a>2.4 其它32位指令</h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>名字</td>
<td>功能</td>
</tr>
<tr>
<td>LDREX</td>
<td>加载字到寄存器，并且在内核中标明一段地址进入了互斥访问状态</td>
</tr>
<tr>
<td>LDREXH</td>
<td>加载半字到寄存器，并且在内核中标明一段地址进入了互斥访问状态</td>
</tr>
<tr>
<td>LDREXB</td>
<td>加载字节到寄存器，并且在内核中标明一段地址进入了互斥访问状态</td>
</tr>
<tr>
<td>STREX</td>
<td>检查将要写入的地址是否已进入了互斥访问状态，如果是则存储寄存器的字</td>
</tr>
<tr>
<td>STREXH</td>
<td>检查将要写入的地址是否已进入了互斥访问状态，如果是则存储寄存器的半字</td>
</tr>
<tr>
<td>STREXB</td>
<td>检查将要写入的地址是否已进入了互斥访问状态，如果是则存储寄存器的字节</td>
</tr>
<tr>
<td>CLREX</td>
<td>在本地的处理上清除互斥访问状态的标记（先前由 LDREX&#x2F;LDREXH&#x2F;LDREXB做的标记）</td>
</tr>
<tr>
<td>MRS</td>
<td>加载特殊功能寄存器的值到通用寄存器</td>
</tr>
<tr>
<td>MSR</td>
<td>存储通用寄存器的值到特殊功能寄存器</td>
</tr>
<tr>
<td>NOP</td>
<td>无操作</td>
</tr>
<tr>
<td>SEV</td>
<td>发送事件</td>
</tr>
<tr>
<td>WFE</td>
<td>休眠并且在发生事件时被唤醒</td>
</tr>
<tr>
<td>WFI</td>
<td>休眠并且在发生中断时被唤醒</td>
</tr>
<tr>
<td>ISB</td>
<td>指令同步隔离（与流水线和 MPU等有关——译注）</td>
</tr>
<tr>
<td>DSB</td>
<td>数据同步隔离（与流水线、MPU 和cache等有关——译注）</td>
</tr>
<tr>
<td>DMB</td>
<td>数据存储隔离（与流水线、MPU 和cache等有关——译注）</td>
</tr>
<tr>
<td>DMB</td>
<td>数据存储器隔离。DMB 指令保证： 仅当所有在它前面的存储器访问操作都执行完毕后，才提交(commit)在它后面的存储器访问操作。</td>
</tr>
<tr>
<td>DSB</td>
<td>数据同步隔离。比 DMB 严格： 仅当所有在它前面的存储器访问操作都执行完毕后，才执行在它后面的指令（亦即任何指令都要等待存储器访 问操作——译者注）</td>
</tr>
<tr>
<td>ISB</td>
<td>指令同步隔离。最严格：它会清洗流水线，以保证所有它前面的指令都执行完毕之后，才执行它后面的指令。</td>
</tr>
</tbody></table>
<h4 id="2-5-立即数"><a href="#2-5-立即数" class="headerlink" title="2.5 立即数"></a>2.5 立即数</h4><p>1、立即数：一个立即数是一块数据存储作为指令本身，而不是在一个中的一部分内容存储器位置或寄存器。立即值通常用于加载值或对常量执行算术或逻辑运算的指令。<br>2、比如一个数 10，把他存入内存中，高级语言表示法是 int i&#x3D;10，这个数放入内存之前叫立即数，放入之后就不是了，再比如一个数 10，把他存入寄存器中，这个数放入寄存器之前叫立即数，放入之后就不是了。</p>
<h4 id="2-6-逻辑数"><a href="#2-6-逻辑数" class="headerlink" title="2.6 逻辑数"></a>2.6 逻辑数</h4><p>逻辑数是用来表示二值逻辑中的”是”与”否”、或称”真”与”假”两个状态的数据。在计算机中，可以用一位基2码表示逻辑数据，即8个逻辑数据可以存放在1个字节中，可用其中的每个bit（位）表示一个逻辑数据。逻辑数可以用计算机中的基2码的两个状态”1”和”0”来表示，其中”1”表示真，”0”表示假。</p>
<h4 id="2-7-逻辑运算和算术运算"><a href="#2-7-逻辑运算和算术运算" class="headerlink" title="2.7 逻辑运算和算术运算"></a>2.7 逻辑运算和算术运算</h4><p>逻辑运算是一种只存在于二进制中的运算。在计组中逻辑运算经常出现的是 或、与、非和异或，这几种运算方式。<br>算数运算我们平常十进制的 加减乘除，但因为在计算机中是二进制所以就只能是加法运算。在计算机中也可以算数运算也可以区分成进位的算数运算和不进位的算数运算。带进位的算数运算</p>
<h3 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h3><h4 id="3-1-MRS"><a href="#3-1-MRS" class="headerlink" title="3.1 MRS"></a>3.1 MRS</h4><p>将状态寄存器CPSR或SPSR的内容移动到一个通用寄存器</p>
<h4 id="3-2-MSR"><a href="#3-2-MSR" class="headerlink" title="3.2 MSR"></a>3.2 MSR</h4><p>将立即数或通用寄存器的内容加载到CPSR或SPSR的指定字段中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MSR CPSR，R0        </span><br><span class="line">MSR SPSR，R0        </span><br><span class="line">MSR CPSR_c，R0</span><br></pre></td></tr></table></figure>

<h4 id="3-3-PRIMASK"><a href="#3-3-PRIMASK" class="headerlink" title="3.3 PRIMASK"></a>3.3 PRIMASK</h4><p>用于disable NMI和硬 fault之外的所有异常，它有效地把当前优先级改为 0（可编程 优先级中的最高优先级）。<br>CPS指令会更改CPSR中的一个或多个模式以及A、I和F位，但不更改其他CPSR位。CPSID就是中断禁止，CPSIE中断允许，</p>
<p>A：表示启用或禁止不精确的中止；I：表示启用或禁止IRQ中断；F：表示启用或禁止FIQ中断</p>
<h4 id="3-4-FAULTMASK"><a href="#3-4-FAULTMASK" class="headerlink" title="3.4 FAULTMASK"></a>3.4 FAULTMASK</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CPSIE f; / CPSID f;</span><br><span class="line"></span><br><span class="line">MSR FAULTMASK,R0</span><br></pre></td></tr></table></figure>

<p>FAULTMASK更绝，它把当前优先级改为-1。这么一来，连硬fault都被掩蔽了。使用方案与<br>PRIMASK的相似。但要注意的是，FAULTMASK会在异常退出时自动清零。</p>
<h4 id="3-5-BX指令"><a href="#3-5-BX指令" class="headerlink" title="3.5 BX指令"></a>3.5 BX指令</h4><p>BX{条件} 目标地址<br>BX 指令跳转到指令中所指定的目标地址，目标地址处的指令既可以是ARM 指令，也可以是Thumb指令。</p>
<h4 id="3-6-零寄存器-wzr、xzr"><a href="#3-6-零寄存器-wzr、xzr" class="headerlink" title="3.6 零寄存器 wzr、xzr"></a>3.6 零寄存器 wzr、xzr</h4><p>因为我们在使用 str 的是没法使用立即数 0 给寄存器赋值，所以 wzr xzr就是干这个事情的。是一个比较特殊又常常见到的寄存器。</p>
<h4 id="3-7-立即寻址指令MOV"><a href="#3-7-立即寻址指令MOV" class="headerlink" title="3.7 立即寻址指令MOV"></a>3.7 立即寻址指令MOV</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SUBS R0,R0,#1   </span><br><span class="line">MOV R0,#0xFF000 </span><br><span class="line">MOV R1,R2    </span><br><span class="line">SUB R0,R1,R2</span><br></pre></td></tr></table></figure>

<h4 id="3-8-寄存器间接寻址指令LDR"><a href="#3-8-寄存器间接寻址指令LDR" class="headerlink" title="3.8 寄存器间接寻址指令LDR"></a>3.8 寄存器间接寻址指令LDR</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR R1,[R2]    </span><br><span class="line">SWP R1,R1,[R2]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">按照从简单到复杂的分类方法，可以通过以下方式来指定访存指令的地址：从寄存器中获取地址；通过寄存器内容再加上偏移来获取地址；对偏移进行扩展、移位等运算之后，再与寄存器内容相加，获得地址。</span><br><span class="line">LDR X0, [X1] ; 直接从寄存器X1的内容中获取地址。</span><br><span class="line">LDR X0, [X1, </span><br><span class="line">LDR X0, [X1, X2] ; X!的内容和X2的内容相加得到地址。</span><br><span class="line">LDR X0, [X1, W2, SXTW] ; 对W2的内容做符号扩展，再与X1的内容相加，作为地址。</span><br><span class="line">LDR X0, [X1, X2, LSL</span><br></pre></td></tr></table></figure>

<h4 id="3-9-寄存器移位寻址指令LSL"><a href="#3-9-寄存器移位寻址指令LSL" class="headerlink" title="3.9 寄存器移位寻址指令LSL"></a>3.9 寄存器移位寻址指令LSL</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV R0,R2,LSL #3     </span><br><span class="line">ANDS R1,R1,R2,LSL R3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">寻址模式</span><br><span class="line"></span><br><span class="line">简单模式：X1的内容不会被改变，例如。</span><br><span class="line">LDR X0, [X1]</span><br><span class="line">LDR X0, [X1, #4]</span><br><span class="line"></span><br><span class="line">前变址模式，X1的内容在load之前变化，例如。</span><br><span class="line">LDR X0, [X1, #4]!</span><br><span class="line">等价于</span><br><span class="line">ADD X1, X1, #4</span><br><span class="line">LDR X0, [X1]</span><br><span class="line"></span><br><span class="line">后变址模式，X1的内容在load之后变化，例如。</span><br><span class="line">LDR X0, [X1], #4</span><br><span class="line">等价于</span><br><span class="line">LDR X0, [X1]</span><br><span class="line">ADD X1, X1, #4</span><br><span class="line"></span><br><span class="line">支持对整型、浮点标量和向量，要求源寄存器和目的寄存器必须具有相同的宽度，例如。</span><br><span class="line">LDP W3, W7, [X0] ; [X0] =&gt; W3, [X0 + 4 bytes] =&gt;W7</span><br><span class="line">STP Q0, Q1, [X4] ; Q0 =&gt; [X4], Q1=&gt;[X4 + 16 bytes]</span><br></pre></td></tr></table></figure>

<h4 id="3-10-基址寻址指令-STR"><a href="#3-10-基址寻址指令-STR" class="headerlink" title="3.10 基址寻址指令 STR"></a>3.10 基址寻址指令 STR</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR R2,[R3,#0x0C]  </span><br><span class="line">STR R1,[R0,#-4]!</span><br></pre></td></tr></table></figure>

<h4 id="3-11-多寄存器寻址指令"><a href="#3-11-多寄存器寻址指令" class="headerlink" title="3.11 多寄存器寻址指令"></a>3.11 多寄存器寻址指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDMIA R1!,&#123;R2-R7,R12&#125;   </span><br><span class="line">STMIA R0!,&#123;R2-R7,R12&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-12-无条件转移B，BAL"><a href="#3-12-无条件转移B，BAL" class="headerlink" title="3.12 无条件转移B，BAL"></a>3.12 无条件转移B，BAL</h4><p>举例： B LABEL ; LABEL为某个位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMP      x3,x4</span><br><span class="line">B.CS     &#123;pc&#125;+0x10 ; 0xc000800094</span><br></pre></td></tr></table></figure>

<p>BCC是指CPSR寄存器条件标志位为0时的跳转。结合CMP R3, R1，意思是比较R3 R1寄存器，当相等时跳转到环测试。因为CMP指令减去两个值并在CPSR中设置条件标志位。</p>
<h4 id="3-13-条件转移B-cont"><a href="#3-13-条件转移B-cont" class="headerlink" title="3.13 条件转移B.cont"></a>3.13 条件转移B.cont</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BEQ 相等</span><br><span class="line">BNE 不等</span><br><span class="line">BPL 非负</span><br><span class="line">BMI 负</span><br><span class="line">BCC 无进位</span><br><span class="line">BCS 有进位</span><br><span class="line">BLO 小于（无符号数）</span><br><span class="line">BHS 大于等于（无符号数）</span><br><span class="line">BHI 大于（无符号数）</span><br><span class="line">BLS 小于等于（无符号数）</span><br><span class="line">BVC 无溢出（有符号数）</span><br><span class="line">BVS 有溢出（有符号数）</span><br><span class="line">BGT 大于（有符号数）</span><br><span class="line">BGE 大于等于（有符号数）</span><br><span class="line">BLT 小于（有符号数）</span><br><span class="line">BLE 小于等于（有符号数）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blr Xm：跳转到由Xm目标寄存器指定的地址处，同时将下一条指令存放到X30寄存器中。例如：blr x20.</span><br><span class="line">br Xm：跳转到由Xm目标寄存器指定的地址处。不是子程序返回</span><br><span class="line">ret &#123;Xm&#125;：跳转到由Xm目标寄存器指定的地址处。是子程序返回。Xm可以不写，默认是X30.</span><br></pre></td></tr></table></figure>

<h4 id="3-14-WFE-和-WFI-对比"><a href="#3-14-WFE-和-WFI-对比" class="headerlink" title="3.14 WFE 和 WFI 对比"></a>3.14 WFE 和 WFI 对比</h4><p>wfi 和 wfe 指令都是让ARM核进入standby睡眠模式。wfi是直到有wfi唤醒事件发生才会唤醒CPU，wfe是直到wfe唤醒事件发生，这两类事件大部分相同。唯一不同之处在于wfe可以被其他CPU上的sev指令唤醒，sec指令用于修改event寄存器的指令。</p>
<p>WFE<br>Wait For Event，是否实现此指令是可选的。如果此指令未实现，它将作为NOP指令来执行。如果指令作为NOP在目标处理器上执行，汇编程序将生成诊断消息。</p>
<p>SEV<br>Set Event，其是否实现是可选的。如果未实现，它将作为NOP执行。如果指令作为NOP在目标上执行，汇编程序将生成诊断消息。<br>SEV在ARMv6T2中作为NOP指令执行。</p>
<h4 id="3-15-MRC：协处理器寄存器到ARM寄存器的数据传输"><a href="#3-15-MRC：协处理器寄存器到ARM寄存器的数据传输" class="headerlink" title="3.15 MRC：协处理器寄存器到ARM寄存器的数据传输"></a>3.15 MRC：协处理器寄存器到ARM寄存器的数据传输</h4><p>MRC指令将协处理器的寄存器中数值传送到ARM处理器的寄存器中。如果协处理器不能成功地执行该操作，将产生未定义的指令异常中断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MRC p2,5,r3,c5,c6协处理器p2把c5和c6经过5操作的结果赋给r3</span><br><span class="line">MRC p3,9,r3,c5,c6,2协处理器p3把c5和c6经过9操作（类型2）的结果赋给r3</span><br></pre></td></tr></table></figure>

<h4 id="3-16-MCR：寄存器到协处理器寄存器的数据传输"><a href="#3-16-MCR：寄存器到协处理器寄存器的数据传输" class="headerlink" title="3.16 MCR：寄存器到协处理器寄存器的数据传输"></a>3.16 MCR：寄存器到协处理器寄存器的数据传输</h4><p>MCR指令将ARM处理器的寄存器中的数据传送到协处理器的寄存器中。如果协处理器不能成功地执行该操作，将产生未定义的指令异常中断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MCR p6,0,r4,c5,c6协处理器p6把r4执行0操作后将结果存放进c5</span><br></pre></td></tr></table></figure>

<h4 id="3-17-STM：将指令中寄存器列表中的各寄存器数值写入到连续的内存单元中"><a href="#3-17-STM：将指令中寄存器列表中的各寄存器数值写入到连续的内存单元中" class="headerlink" title="3.17 STM：将指令中寄存器列表中的各寄存器数值写入到连续的内存单元中"></a>3.17 STM：将指令中寄存器列表中的各寄存器数值写入到连续的内存单元中</h4><p>STM指令是Store Multiple的缩写，它的作用是将多个寄存器的值保存到栈中。在ARM汇编中，栈是一种后进先出 (LIFO)的数据结构，用来存储临时数据和函数调用过程中的返回地址</p>
<p>STM指令的语法如下:</p>
<p>其中，条件码是可选项，用来指定条件执行STM指令的条件;模式用来指定存储模式，</p>
<p><strong>1、寻址模式（mode）</strong><br>mode决定了基址寄存器是在执行指令前地址增减还是指令执行后增减.<br>I为Increment(递增)<br>D为Decrement (递减)<br>B为Before<br>A为After</p>
<p>常用的模式有IA (递增后存储) 、IB (递增前存储) 、DA (减后存储)和DB(递减前存储);SP是栈指针寄存器，用来指定栈的起始地址;寄存器列表指定要保存的寄存器。<br>另外四种也是寻址模式<br>FD 慢递减堆栈<br>FA 满递增堆栈<br>ED 空递减堆栈<br>EA 空递增堆栈</p>
<p>在上述代码中，STMFD指令存储了RO、R1和R2的值到栈中。SP!表示栈指针寄存器递增，即存储完后栈指针自动增加，以便下一次保存操作。</p>
<p><strong>2、“!”</strong><br>在传输数据完成后，更新基址寄存器中的值</p>
<p><strong>3、“^”</strong></p>
<p>在数据传输完成后，将SPSR的值复制到CPSR中，常用于异常模式下的返回.</p>
<h4 id="3-18-LDM：将数据从连续内存单元中读取到指令的寄存器列表中的各寄存器中"><a href="#3-18-LDM：将数据从连续内存单元中读取到指令的寄存器列表中的各寄存器中" class="headerlink" title="3.18 LDM：将数据从连续内存单元中读取到指令的寄存器列表中的各寄存器中"></a>3.18 LDM：将数据从连续内存单元中读取到指令的寄存器列表中的各寄存器中</h4><p>LDMIA</p>
<h4 id="3-19-LDR：从内存中将一个32位的字读取到目标寄存器"><a href="#3-19-LDR：从内存中将一个32位的字读取到目标寄存器" class="headerlink" title="3.19 LDR：从内存中将一个32位的字读取到目标寄存器"></a>3.19 LDR：从内存中将一个32位的字读取到目标寄存器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldr 加载指令： LDR&#123;条件&#125; 目的寄存器，&lt;存储器地址&gt;</span><br></pre></td></tr></table></figure>

<p>LDR指令用亍从存储器中将一个32位的字数据传送到目的寄存器中。该指令通常用于从存储器中读取32位的字数据到通用寄存器，然后对数据进行处理。当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。</p>
<h4 id="3-20-STR：将32位字数据写入到指定的内存单元"><a href="#3-20-STR：将32位字数据写入到指定的内存单元" class="headerlink" title="3.20 STR：将32位字数据写入到指定的内存单元"></a>3.20 STR：将32位字数据写入到指定的内存单元</h4><p>STR指令的格式为：</p>
<p>STR指令用亍从源寄存器中将一个32位的字数据传送到存储器中。该指令在程序设计中比较常用，寻址方式灵活多样，使用方式可参考指令LDR。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STR R0，[R1]，＃8  ；将R0中的字数据写入以R1为地址的存储器中，并将新地址R1＋8写入R1。</span><br><span class="line">STR R0，[R1，＃8]  ；将R0中的字数据写入以R1＋8为地址的存储器中。</span><br><span class="line">str     r1, [r0]  ；将r1寄存器的值，传送到地址值为r0的（存储器）内存中</span><br></pre></td></tr></table></figure>

<h4 id="3-21-SWI：软中断指令"><a href="#3-21-SWI：软中断指令" class="headerlink" title="3.21 SWI：软中断指令"></a>3.21 SWI：软中断指令</h4><p>SWI指令格式如下：</p>
<p>MOV R0,#34 ；设置功能号为34<br>SWI 12 ；产生软中断，中断号为12</p>
<h4 id="3-22-BIC清除位"><a href="#3-22-BIC清除位" class="headerlink" title="3.22 BIC清除位"></a>3.22 BIC清除位</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BIC指令的格式为： BIC&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure>

<p>BIC指令用于清除操作数1的某些位，并把结果放置到目的寄存器中。操作数1应是一个寄存器， 操作数2可以是一个寄存器、被移位的寄存器、或一个立即数。操作数2为32位的掩码，如果在 掩码中置了某一位1，则清除这一位。未设置的掩码位保持不变。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BIC R0,R0,#0X1F</span><br><span class="line">0X1F=11111B</span><br><span class="line"></span><br><span class="line">BIC R4, R4, #0xFF000000 指令将E4高8位清除为0</span><br></pre></td></tr></table></figure>

<h4 id="3-23-EOR逻辑异或指令"><a href="#3-23-EOR逻辑异或指令" class="headerlink" title="3.23 EOR逻辑异或指令"></a>3.23 EOR逻辑异或指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EOR&#123;&lt;cond&gt;&#125;&#123;S&#125; &lt;Rd&gt;,&lt;Rn&gt;,&lt;shifter_operand&gt;</span><br></pre></td></tr></table></figure>

<p>逻辑异或EOR（Exclusive OR）指令将寄存器中的值和<shifter_operand>的值执行按位“异或”操作，并将执行结果存储到目的寄存器中，同时根据指令的执行结果更新CPSR中相应的条件标志位。</p>
<h4 id="3-24-CMN与负数对比"><a href="#3-24-CMN与负数对比" class="headerlink" title="3.24 CMN与负数对比"></a>3.24 CMN与负数对比</h4><p>CMN 同于 CMP，但它允许你与负值进行比较，比如难于用其他方法实现的用于结束列表的 -1。这样与 -1 比较将使用:<br>CMN R0, #1 ; 把 R0 与 -1 进行比较</p>
<h4 id="3-25-MVN取反"><a href="#3-25-MVN取反" class="headerlink" title="3.25 MVN取反"></a>3.25 MVN取反</h4><p>将每一位操作数都取反，若为有符号的数据则进行补码保存</p>
<p>其中上图中的0x4用二进制数(00000100)表示, 然后对其取反得到（11111011），可见取反后为负数，因此针对负数求其补码则为储存在R0中的值，先将负数最高位转换为正数（01111011）取反，得到（10000100），加1得到其补码，最后结果为（10000101），即结果为-5；</p>
<h4 id="3-26-LSL（Logical-Shift-Left）左移运算"><a href="#3-26-LSL（Logical-Shift-Left）左移运算" class="headerlink" title="3.26 LSL（Logical Shift Left）左移运算"></a>3.26 LSL（Logical Shift Left）左移运算</h4><p>用于将寄存器的值向左移位，末尾填充0。在ARM处理器中，每个寄存器都有32位，当LSL被使用时，指令将寄存器中的二进制数值向左移动指定的位数，并用0填充未使用的右侧位数。</p>
<h4 id="3-27-STP"><a href="#3-27-STP" class="headerlink" title="3.27 STP"></a>3.27 STP</h4><p>STP是一条用于将General-Purpose Registers（通用寄存器）的值存储到内存地址的指令。STP是Store Pair的缩写，用于同时将两个寄存器的值存储到连续的内存地址中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STP &lt;Rt1&gt;, &lt;Rt2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]</span><br></pre></td></tr></table></figure>

<p>Rt1和Rt2是要存储的寄存器，可以是X0-X30中的任何一个。<br>Xn是基础地址寄存器，可以是X0-X30中的任何一个，但不能是Rt1或Rt2。<br>#是一个常数值，用于指定一个偏移量，范围是-2048到2047。<br>例如，以下是使用STP指令将X2和X3寄存器的值存储到基础地址寄存器X18指定的内存地址偏移24字节处的代码：</p>
<p>注意：结尾的!表示同时更新基础寄存器的值，即存储操作后，X18将指向下一个地址。如果不需要更新基础寄存器，可以省略!</p>
<h3 id="实例解析"><a href="#实例解析" class="headerlink" title="实例解析"></a>实例解析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IMPORT |Image$RW_IRAM1$Base|            </span><br><span class="line">IMPORT |Image$RW_IRAM1$Length|         </span><br><span class="line">IMPORT |Load$RW_IRAM1$Base|            </span><br><span class="line">IMPORT |Image$RW_IRAM1$ZI$Base|        </span><br><span class="line">IMPORT |Image$RW_IRAM1$ZI$Length|      </span><br><span class="line">Load$$region_name$$Base 	</span><br><span class="line">Load$$region_name$$Length 	</span><br><span class="line">Load$$region_name$$Limit</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LDR R0, = |Load$RW_IRAM1$Base|           </span><br><span class="line">LDR R1, = |Image$RW_IRAM1$Base|   </span><br><span class="line">LDR R2, = |Image$RW_IRAM1$Length| </span><br><span class="line">CopyData                </span><br><span class="line">SUB R2, R2, #4                      </span><br><span class="line">LDR R3, [R0, R2]                    </span><br><span class="line">STR R3, [R1, R2]                   </span><br><span class="line">CMP R2, #0                         </span><br><span class="line">BNE CopyData                      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LDR R0, = |Image$RW_IRAM1$ZI$Base|   </span><br><span class="line">LDR R1, = |Image$RW_IRAM1$ZI$Length| </span><br><span class="line">CleanBss        </span><br><span class="line">SUB R1, R1, #4                                                </span><br><span class="line">MOV R3, #0                                                  </span><br><span class="line">STR R3, [R0, R1]                                        </span><br><span class="line">CMP R1, #0                                                 </span><br><span class="line">BNE CleanBss                       </span><br><span class="line"></span><br><span class="line">IMPORT  mymain                                              </span><br><span class="line">BL                mymain                                    </span><br><span class="line">B                .                                          </span><br><span class="line">ENDP</span><br><span class="line">ALIGN                                                      </span><br><span class="line">END</span><br></pre></td></tr></table></figure>


<h2 id="Android系统源码基础"><a href="#Android系统源码基础" class="headerlink" title="Android系统源码基础"></a>Android系统源码基础</h2><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><ul>
<li>用户可见的所有应用（系统自带或用户安装）<ul>
<li>比如：电话、短信、浏览器、相机、设置</li>
</ul>
</li>
<li>应用通过 API 与系统框架层交互</li>
</ul>
<h4 id="应用框架层"><a href="#应用框架层" class="headerlink" title="应用框架层"></a>应用框架层</h4><ul>
<li>为开发者提供的核心 Java API</li>
<li>提供各种系统服务的访问接口，如：</li>
</ul>
<table>
<thead>
<tr>
<th>模块</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>ActivityManager</code></td>
<td>管理应用生命周期和任务栈</td>
</tr>
<tr>
<td><code>WindowManager</code></td>
<td>管理窗口显示与焦点</td>
</tr>
<tr>
<td><code>PackageManager</code></td>
<td>管理应用安装、权限等</td>
</tr>
<tr>
<td><code>ContentProvider</code></td>
<td>跨应用数据共享</td>
</tr>
<tr>
<td><code>NotificationManager</code></td>
<td>通知控制</td>
</tr>
<tr>
<td><code>LocationManager</code></td>
<td>定位服务</td>
</tr>
</tbody></table>
<h4 id="系统运行库层"><a href="#系统运行库层" class="headerlink" title="系统运行库层"></a>系统运行库层</h4><h5 id="Android-Runtime（ART）"><a href="#Android-Runtime（ART）" class="headerlink" title="Android Runtime（ART）"></a>Android Runtime（ART）</h5><ul>
<li>每个应用进程有独立的 ART 实例</li>
<li>负责：<ul>
<li>执行 <code>.dex</code> 字节码（通过 JIT 或 AOT 编译）</li>
<li>管理内存、垃圾回收</li>
</ul>
</li>
</ul>
<h5 id="C-C-原生库（Native-Libraries）"><a href="#C-C-原生库（Native-Libraries）" class="headerlink" title="C&#x2F;C++ 原生库（Native Libraries）"></a>C&#x2F;C++ 原生库（Native Libraries）</h5><ul>
<li>使用 C&#x2F;C++ 实现的系统功能库，如：</li>
</ul>
<table>
<thead>
<tr>
<th>库</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>libc</code></td>
<td>标准 C 库</td>
</tr>
<tr>
<td><code>libm</code></td>
<td>数学库</td>
</tr>
<tr>
<td><code>OpenGL ES</code></td>
<td>图形渲染</td>
</tr>
<tr>
<td><code>SQLite</code></td>
<td>数据库存储</td>
</tr>
<tr>
<td><code>libmedia</code></td>
<td>音视频编解码</td>
</tr>
</tbody></table>
<h4 id="硬件抽象层"><a href="#硬件抽象层" class="headerlink" title="硬件抽象层"></a>硬件抽象层</h4><ul>
<li>定义标准接口，让上层服务无需关心具体硬件</li>
<li>OEM 厂商通过 HAL 实现对硬件的控制，比如：</li>
</ul>
<table>
<thead>
<tr>
<th>模块</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>camera.default.so</code></td>
<td>摄像头驱动</td>
</tr>
<tr>
<td><code>audio.primary.so</code></td>
<td>音频驱动</td>
</tr>
<tr>
<td><code>lights.default.so</code></td>
<td>灯光控制</td>
</tr>
<tr>
<td><code>sensors.default.so</code></td>
<td>传感器读取</td>
</tr>
</tbody></table>
<h4 id="Linux内核层"><a href="#Linux内核层" class="headerlink" title="Linux内核层"></a>Linux内核层</h4><ul>
<li>Android 运行在修改版的 Linux 内核上</li>
<li>提供：<ul>
<li>线程管理</li>
<li>内存管理</li>
<li>电源管理</li>
<li>安全机制（SEAndroid）</li>
<li>驱动接口（用于与硬件直接通信）</li>
</ul>
</li>
</ul>
<h3 id="源码目录结构"><a href="#源码目录结构" class="headerlink" title="源码目录结构"></a>源码目录结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">AOSP_ROOT/</span><br><span class="line">├── art/                  → Android Runtime（ART）</span><br><span class="line">├── bionic/               → C 标准库实现（libc、libm、libdl）</span><br><span class="line">├── bootable/             → 启动引导（bootloader、recovery）</span><br><span class="line">├── build/                → 构建系统脚本（makefile, Soong）</span><br><span class="line">├── compatibility/        → CTS（兼容性测试套件）</span><br><span class="line">├── dalvik/               → Dalvik 虚拟机（已被 ART 替代，保留部分兼容性）</span><br><span class="line">├── development/          → 开发工具、调试工具</span><br><span class="line">├── device/               → 各品牌/型号的设备配置（BoardConfig.mk 等）</span><br><span class="line">├── external/             → 第三方开源库（openssl、zlib、protobuf 等）</span><br><span class="line">├── frameworks/           → Java 框架层源码（核心 API、系统服务）</span><br><span class="line">├── hardware/             → 硬件抽象层（HAL）接口与实现</span><br><span class="line">├── kernel/               → Linux 内核源码（有时是 symbolic link）</span><br><span class="line">├── libcore/              → Java 基础类库实现（java.lang, java.util等）</span><br><span class="line">├── libnativehelper/      → JNI 帮助函数（native &lt;-&gt; Java 桥接）</span><br><span class="line">├── packages/             → 系统应用（设置、桌面、输入法、浏览器等）</span><br><span class="line">├── platform_testing/     → 平台测试框架</span><br><span class="line">├── prebuilts/            → 预编译的工具链（GCC、Clang、Java 等）</span><br><span class="line">├── sdk/                  → SDK 构建工具相关源码</span><br><span class="line">├── system/               → 核心系统服务（init、vold、core、server）</span><br><span class="line">├── test/                 → 测试相关内容</span><br><span class="line">├── tools/                → 构建工具集（adb、aapt 等）</span><br><span class="line">├── vendor/               → 厂商特定代码（闭源驱动或 HAL 模块实现）</span><br><span class="line">└── out/                  → 编译输出目录（构建后生成）</span><br></pre></td></tr></table></figure>

<p>参考： <a target="_blank" rel="noopener" href="https://wx.comake.online/doc/doc/SigmaStarDocs-SSD238X-Android-20240712/platform/Android/arch.html">https://wx.comake.online/doc/doc/SigmaStarDocs-SSD238X-Android-20240712/platform/Android/arch.html</a></p>
<h2 id="Frida-使用"><a href="#Frida-使用" class="headerlink" title="Frida 使用"></a>Frida 使用</h2><p>frida hook有两种模式，如下<br>        1. attach模式<br>        attach到已经存在的进程，核心原理是ptrace修改进程内存。如果此时进程已经处于调试状态(比如做了反调试)，则会attach失败。<br>        2. spawn模式<br>      启动一个新的进程并挂起，在启动的同时注入frida代码，适用于在进程启动前的一些hook，比如hook RegisterNative函数，注入完成后再调用resume恢复进程。</p>
<h3 id="将一个脚本注入到Android目标进程"><a href="#将一个脚本注入到Android目标进程" class="headerlink" title="将一个脚本注入到Android目标进程"></a>将一个脚本注入到Android目标进程</h3><p><strong>使用usb进行hook</strong><br><code>frida -U -l myhook.js com.xxx.xxxx</code><br>参数解释：</p>
<ul>
<li>-U 指定对USB设备操作</li>
<li>-l 指定加载一个Javascript脚本</li>
<li>最后指定一个进程名，如果想指定进程pid,用<code>-p</code>选项。正在运行的进程可以用<code>frida-ps -U</code>命令查看</li>
</ul>
<p><strong>使用host进行hook</strong><br>需要现在手机启动 frida服务<code>frida -l 0.0.0.0 5555</code>相当于在手机启动一个监听，然后通过adb转发下端口，<code>adb forward tcp:5555 tcp:5555</code>就可以转发到本地,之后在 使用 <code>frida -H 127.0.0.1:5555 -l test.js</code>命令去加载脚本进行hook</p>
<p>**加 <code>-f 包名</code>**：<br>    → 是让 Frida <em>启动</em> 一个新的进程（就是指定的包名&#x2F;应用），<br>    → <strong>然后</strong> 在进程一启动起来（通常非常早期，甚至在 <code>main</code> 函数之前）就把你的脚本 <em>注入</em> 进去。<br>    → 这种方式叫 <strong>spawn attach模式</strong>（或者说spawn模式），<br>    → 比 attach 普通运行时更早，可以抓到早期行为，比如 Native 层动态注册、加固解密什么的。<br>    → 但是，需要手动 <code>resume()</code> 继续进程。</p>
<ul>
<li><strong>不加 <code>-f</code>，直接指定一个正在运行的进程名&#x2F;包名</strong>：<br>  → Frida 是直接 <strong>attach到已经在运行</strong>的进程上，<br>  → 这种就是普通的 <strong>attach模式</strong>。<br>  → 只能看到 attach 时刻之后的行为，前面的（比如早期解密）可能已经错过了。</li>
</ul>
<h3 id="Hook-Java"><a href="#Hook-Java" class="headerlink" title="Hook Java"></a>Hook Java</h3><p>一个hook的固定模版</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> &lt;class_reference&gt; = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;&lt;package_name&gt;.&lt;class&gt;&quot;</span>);</span><br><span class="line">  &lt;class_reference&gt;.&lt;method_to_hook&gt;.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">&lt;args&gt;</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      我们自己的方法实现</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p> Java.perform 是 Frida 中用于创建一个特殊上下文的函数，让你的脚本能够与 Android 应用程序中的 Java 代码进行交互。它就像是打开了一扇门，让你能够访问并操纵应用程序内部运行的 Java 代码。一旦进入这个上下文，你就可以执行诸如钩取方法或访问 Java 类等操作来控制或观察应用程序的行为。</p>
<p>Java.use方法用于加载一个Java类，相当于Java中的<code>Class.forName()</code>。比如要加载一个String类：<br><code>var StringClass = Java.use(&quot;java.lang.String&quot;);</code><br>加载内部类：<br><code>var MyClass_InnerClass = Java.use(&quot;com.luoyesiqiu.MyClass$InnerClass&quot;);</code><br>其中InnerClass是MyClass的内部类</p>
<h4 id="带参数的构造函数"><a href="#带参数的构造函数" class="headerlink" title="带参数的构造函数"></a>带参数的构造函数</h4><p>修改参数为byte[]类型的构造函数的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassName.$init.overload(<span class="string">&#x27;[B&#x27;</span>).implementation=function(param)&#123;    </span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：ClassName是使用Java.use定义的类;param是可以在函数体中访问的参数</p>
</blockquote>
<p>修改多参数的构造函数的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassName.$init.overload(<span class="string">&#x27;[B&#x27;</span>,<span class="string">&#x27;int&#x27;</span>,<span class="string">&#x27;int&#x27;</span>).implementation=function(param1,param2,param3)&#123;    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="无参数构造函数"><a href="#无参数构造函数" class="headerlink" title="无参数构造函数"></a>无参数构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName.$init.overload().implementation=function()&#123;    <span class="comment">//do something&#125;</span></span><br></pre></td></tr></table></figure>

<p>调用原构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName.$init.overload().implementation=function()&#123;    <span class="comment">//do something    this.$init();    //do something&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：当构造函数(函数)有多种重载形式，比如一个类中有两个形式的func：<code>void func()</code>和<code>void func(int)</code>，要加上overload来对函数进行重载，否则可以省略overload</p>
</blockquote>
<h4 id="一般函数"><a href="#一般函数" class="headerlink" title="一般函数"></a>一般函数</h4><p>修改函数名为func，参数为byte[]类型的函数的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName.func.overload(<span class="string">&#x27;[B&#x27;</span>).implementation=function(param)&#123;    <span class="comment">//do something    //return ...&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="无参数的函数"><a href="#无参数的函数" class="headerlink" title="无参数的函数"></a>无参数的函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName.func.overload().implementation=function()&#123;    <span class="comment">//do something&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注： 在修改函数实现时，如果原函数有返回值，那么我们在实现时也要返回合适的值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName.func.overload().implementation=function()&#123;    //do something    return this.func();&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><p>和Java一样，创建类实例就是调用构造函数，而在这里用<code>$new</code>表示一个构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ClassName=Java.use(<span class="string">&quot;com.luoye.test.ClassName&quot;</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">instance</span> <span class="operator">=</span> ClassName.$<span class="keyword">new</span>();</span><br></pre></td></tr></table></figure>

<p>实例化以后调用其他函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ClassName=Java.use(<span class="string">&quot;com.luoye.test.ClassName&quot;</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">instance</span> <span class="operator">=</span> ClassName.$<span class="keyword">new</span>();</span><br><span class="line">instance.func();</span><br></pre></td></tr></table></figure>

<h4 id="字段操作"><a href="#字段操作" class="headerlink" title="字段操作"></a>字段操作</h4><p>字段赋值和读取要在字段名后加<code>.value</code>，假设有这样的一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.luoyesiqiu.app;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;    </span><br><span class="line">	<span class="keyword">private</span> String name;    </span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>写个脚本操作Person类的name字段和age字段：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person_class = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.luoyesiqiu.app.Person&quot;</span>);<span class="comment">//实例化Person类</span></span><br><span class="line"><span class="keyword">var</span> person_class_instance = person_class.$new();</span><br><span class="line"><span class="comment">//给name字段赋值</span></span><br><span class="line">person_class_instance.<span class="property">name</span>.<span class="property">value</span> = <span class="string">&quot;luoyesiqiu&quot;</span>;</span><br><span class="line"><span class="comment">//给age字段赋值</span></span><br><span class="line">person_class_instance.<span class="property">age</span>.<span class="property">value</span> = <span class="number">18</span>;</span><br><span class="line"><span class="comment">//输出name字段和age字段的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name = &quot;</span>,person_class_instance.<span class="property">name</span>.<span class="property">value</span>, <span class="string">&quot;,&quot;</span> ,<span class="string">&quot;age = &quot;</span> ,person_class_instance.<span class="property">age</span>.<span class="property">value</span>);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = luoyesiqiu , age = <span class="number">18</span></span><br></pre></td></tr></table></figure>

<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>用<code>Java.cast</code>方法来对一个对象进行类型转换，如将<code>variable</code>转换成<code>java.lang.String</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">StringClass</span>=<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">NewTypeClass</span>=<span class="title class_">Java</span>.<span class="title function_">cast</span>(variable,<span class="title class_">StringClass</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Java-available字段"><a href="#Java-available字段" class="headerlink" title="Java.available字段"></a>Java.available字段</h4><p>这个字段标记Java虚拟机（例如： Dalvik 或者 ART）是否已加载, 操作Java任何东西之前，要确认这个值是否为true</p>
<h4 id="Java-perform方法"><a href="#Java-perform方法" class="headerlink" title="Java.perform方法"></a>Java.perform方法</h4><p>Java.perform(fn)在Javascript代码成功被附加到目标进程时调用，我们核心的代码要在里面写。格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(function()&#123;<span class="comment">//do something...&#125;);</span></span><br></pre></td></tr></table></figure>
<p>参考：<br><a target="_blank" rel="noopener" href="https://www.daowuya.love/frida%E7%94%A8%E6%B3%95%E4%B9%8Bhook-java%E5%B1%82%E4%BB%A3%E7%A0%81/">https://www.daowuya.love/frida%E7%94%A8%E6%B3%95%E4%B9%8Bhook-java%E5%B1%82%E4%BB%A3%E7%A0%81/</a></p>
<p>来看一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> a.b.k0801;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.widget.EditText;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> a.b.k0801.databinding.ActivityMainBinding;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Used to load the &#x27;k0801&#x27; library on application startup.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"></span><br><span class="line">System.loadLibrary(<span class="string">&quot;k0801&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ActivityMainBinding binding;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">binding = ActivityMainBinding.inflate(getLayoutInflater());</span><br><span class="line"></span><br><span class="line">setContentView(binding.getRoot());</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Example of a call to a native method</span></span><br><span class="line"></span><br><span class="line"><span class="type">EditText</span> <span class="variable">et_userName</span> <span class="operator">=</span> binding.etUserName;</span><br><span class="line"></span><br><span class="line"><span class="type">EditText</span> <span class="variable">et_key</span> <span class="operator">=</span> binding.etKey;</span><br><span class="line"></span><br><span class="line"><span class="type">TextView</span> <span class="variable">tv_result</span> <span class="operator">=</span> binding.tvResult;</span><br><span class="line"></span><br><span class="line"><span class="type">Button</span> <span class="variable">btn_reg</span> <span class="operator">=</span> binding.btnOk;</span><br><span class="line"></span><br><span class="line">btn_reg.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(checkSN(et_userName.getText().toString().trim(), et_key.getText().toString().trim()))&#123;</span><br><span class="line"></span><br><span class="line">tv_result.setText(<span class="string">&quot;注册成功!&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">tv_result.setText(<span class="string">&quot;注册失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkSN</span><span class="params">(String userName, String sn)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((userName == <span class="literal">null</span>) || (userName.length() == <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((sn == <span class="literal">null</span>) || (sn.length() != <span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">MessageDigest</span> <span class="variable">digest</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line"></span><br><span class="line">digest.reset();</span><br><span class="line"></span><br><span class="line">digest.update(userName.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] bytes = digest.digest(); <span class="comment">//采用MD5对用户名进行Hash</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">hexstr</span> <span class="operator">=</span> bytes.toString(); <span class="comment">//将计算结果转化成字符串</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; hexstr.length(); i += <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">sb.append(hexstr.charAt(i));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">userSN</span> <span class="operator">=</span> sb.toString(); <span class="comment">//计算出的SN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!userSN.equalsIgnoreCase(sn)) <span class="comment">//比较注册码是否正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* A native method that is implemented by the &#x27;k0801&#x27; native library,</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* which is packaged with this application.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">stringFromJNI</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hook脚本</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 hook 主函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hook_java_main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// Java.perform 确保代码在 Java 虚拟机运行后执行</span></span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 Java 类 a.b.k0801.MainActivity 的句柄</span></span><br><span class="line">        <span class="keyword">var</span> cls_MainActivity = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;a.b.k0801.MainActivity&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 checkSN(String, String) 方法的特定重载版本</span></span><br><span class="line">        <span class="keyword">var</span> fun_checkSN = cls_MainActivity.<span class="property">checkSN</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.lang.String&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写该方法的实现逻辑</span></span><br><span class="line">        fun_checkSN.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">p0, p1</span>)&#123;</span><br><span class="line">            <span class="comment">// 打印原始输入参数</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;checkSN in:&quot;</span>, p0, p1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 替换参数为固定值</span></span><br><span class="line">            p0 = <span class="string">&quot;cccc&quot;</span>;</span><br><span class="line">            p1 = <span class="string">&quot;dddd&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用原始方法逻辑（此处已经替换了参数）</span></span><br><span class="line">            <span class="keyword">var</span> ret = <span class="variable language_">this</span>.<span class="title function_">checkSN</span>(p0, p1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改返回值为 true，无论原始逻辑返回什么</span></span><br><span class="line">            ret = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印输出结果</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;checkSN out:&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回修改后的值</span></span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印 hook 完成的提示信息</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hook_java_main run over&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟执行 hook 函数，确保目标应用已加载完成</span></span><br><span class="line"><span class="built_in">setTimeout</span>(hook_java_main, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Hook-Native"><a href="#Hook-Native" class="headerlink" title="Hook Native"></a>Hook Native</h3><h4 id="Hook-Native层中调用的函数并且读取传入的参数"><a href="#Hook-Native层中调用的函数并且读取传入的参数" class="headerlink" title="Hook Native层中调用的函数并且读取传入的参数"></a>Hook Native层中调用的函数并且读取传入的参数</h4><p>先来看看模版</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(targetAddress, &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Entering &#x27;</span> + functionName);</span><br><span class="line">        <span class="comment">// Modify or log arguments if needed</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Leaving &#x27;</span> + functionName);</span><br><span class="line">        <span class="comment">// Modify or log return value if needed</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>Interceptor.attach：将回调函数附加到指定的函数地址。targetAddress 应该是我们想要挂钩的本地函数的地址。</code><br><code>onEnter：当挂钩的函数被调用时，调用此回调。它提供对函数参数 (args) 的访问。</code><br><code>onLeave：当挂钩的函数即将退出时，调用此回调。它提供对返回值 (retval) 的访问。</code></p>
<p>需要获取targetAddress我们可以方便的使用如下API:</p>
<p><code>Module.enumerateExports()</code><br>通过调用 Module.enumerateExports()，我们可以获取到导出函数的名称、地址以及其他相关信息。这些信息对于进行函数挂钩、函数跟踪或者调用其他函数都非常有用。</p>
<p><code>Module.getExportByName()</code><br>当我们知道要查找的导出项的名称但不知道其地址时，可以使用 Module.getExportByName()。通过提供导出项的名称作为参数，这个函数会返回与该名称对应的导出项的地址。</p>
<p><code>Module.findExportByName()</code><br>这与 Module.getExportByName() 是一样的。唯一的区别在于，如果未找到导出项，Module.getExportByName() 会引发异常，而 Module.findExportByName() 如果未找到导出项则返回 null。让我们看一个示例。</p>
<p><code>Module.getBaseAddress()</code><br>通过调用 Module.getBaseAddress() 函数，我们可以获取指定模块的基址地址，然后可以基于这个基址地址进行偏移计算，以定位模块内部的特定函数、变量或者数据结构</p>
<p><code>Module.enumerateImports()</code><br>通过调用 Module.enumerateImports() 函数，我们可以获取到指定模块导入的外部函数或变量的名称、地址以及其他相关信息。</p>
<p>参考： <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_24481913/article/details/136546413">https://blog.csdn.net/qq_24481913/article/details/136546413</a></p>
<p>对于没有导出的函数如何进行hook呢,就要利用ida找出该函数在内存中的便宜加上基址</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如你知道 libtarget.so 中某函数偏移是 0x1234</span></span><br><span class="line"><span class="keyword">var</span> base = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(<span class="string">&quot;libtarget.so&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> target = base.<span class="title function_">add</span>(<span class="number">0x1234</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(target, &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hooked non-exported function&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;return value:&quot;</span>, retval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Hook修改native层程序返回值"><a href="#Hook修改native层程序返回值" class="headerlink" title="Hook修改native层程序返回值"></a>Hook修改native层程序返回值</h4><img src="/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250501184207452.png" class="">

<p>hook的代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hook</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> check_flag = <span class="title class_">Module</span>.<span class="title function_">enumerateExports</span>(<span class="string">&quot;liba0x9.so&quot;</span>)[<span class="number">0</span>][<span class="string">&quot;address&quot;</span>];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Func address = &quot;</span>,check_flag);</span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(check_flag,&#123;</span><br><span class="line">        <span class="attr">onEnter</span>:<span class="keyword">function</span> (<span class="params">args</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="attr">onLeave</span>:<span class="keyword">function</span> (<span class="params">retval</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Origin retval : &quot;</span>,retval);</span><br><span class="line">            retval.<span class="title function_">replace</span>(<span class="number">1337</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">hook</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(hook);</span><br></pre></td></tr></table></figure>

<h4 id="调用native层中未被调用的方法"><a href="#调用native层中未被调用的方法" class="headerlink" title="调用native层中未被调用的方法"></a>调用native层中未被调用的方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> native_adr = <span class="keyword">new</span> <span class="title class_">NativePointer</span>(&lt;address_of_the_native_function&gt;);</span><br><span class="line"><span class="keyword">const</span> native_function = <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(native_adr, <span class="string">&#x27;&lt;return type&gt;&#x27;</span>, [<span class="string">&#x27;argument_data_type&#x27;</span>]);</span><br><span class="line"><span class="title function_">native_function</span>(&lt;<span class="variable language_">arguments</span>&gt;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> native_adr = <span class="keyword">new</span> <span class="title class_">NativePointer</span>(&lt;address_of_the_native_function&gt;);</span><br></pre></td></tr></table></figure>

<p>要在 Frida 中调用一个本地函数，我们需要一个 NativePointer 对象。我们应该将要调用的本地函数的地址传递给 NativePointer 构造函数。接下来，我们将创建 NativeFunction 对象，它表示我们想要调用的实际本地函数。它在本地函数周围创建一个 JavaScript 包装器，允许我们从 Frida 调用该本地函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> native_function = <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(native_adr, <span class="string">&#x27;&lt;return type&gt;&#x27;</span>, [<span class="string">&#x27;argument_data_type&#x27;</span>]);</span><br></pre></td></tr></table></figure>

<p>第一个参数应该是 NativePointer 对象，第二个参数是本地函数的返回类型，第三个参数是要传递给本地函数的参数的数据类型列表。现在我们可以像在 Java 空间中那样调用该方法了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">native_function</span>(&lt;<span class="variable language_">arguments</span>&gt;);</span><br></pre></td></tr></table></figure>

<p>看看例子</p>
<img src="/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250501184813781.png" class="">

<p>发现就是在主函数中加载了stringFromJNI，没有关于flag的信息，但是有未被调用的flag函数，我们直接使用hook调用它输出log</p>
<img src="/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/IMAGE20250501184833285.png" class="">

<p>hook代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hook</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(<span class="string">&quot;libfrida0xa.so&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> b = <span class="title class_">Module</span>.<span class="title function_">enumerateExports</span>(<span class="string">&quot;libfrida0xa.so&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> get_flagaddress = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> mvaddress = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; b[i]!= <span class="literal">null</span> ; i ++ )&#123;</span><br><span class="line">        <span class="comment">// console.log(b[i][&quot;name&quot;])</span></span><br><span class="line">        <span class="keyword">if</span>(b[i][<span class="string">&quot;name&quot;</span>] == <span class="string">&quot;_Z8get_flagii&quot;</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;function get_flag : &quot;</span>,b[i][<span class="string">&quot;address&quot;</span>]);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>((b[i][<span class="string">&quot;address&quot;</span>] - a).<span class="title function_">toString</span>(<span class="number">16</span>));</span><br><span class="line">     <span class="comment">//       mvaddress = b[i][&quot;address&quot;] - a;</span></span><br><span class="line">            get_flagaddress = b[i][<span class="string">&quot;address&quot;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(ptr.<span class="title function_">toString</span>(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> get_flag_ptr = <span class="keyword">new</span> <span class="title class_">NativePointer</span>(get_flagaddress);</span><br><span class="line">    <span class="keyword">const</span> get_flag = <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(get_flag_ptr,<span class="string">&#x27;char&#x27;</span>,[<span class="string">&#x27;int&#x27;</span>,<span class="string">&#x27;int&#x27;</span>]);</span><br><span class="line">    <span class="keyword">var</span> flag = <span class="title function_">get_flag</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(flag)</span><br><span class="line">    <span class="comment">//console.log(b);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">hook</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure>

<h4 id="主动调用native中的函数"><a href="#主动调用native中的函数" class="headerlink" title="主动调用native中的函数"></a>主动调用native中的函数</h4><p>1、new NativeFunction(要调用的函数地址，函数返回值，[参数]);<br>2、参数需要保证在内存里，所以字符串要申请内存 Memory.allocUtf8String()</p>
<p>如下演示了一个写入字符到文件中的示例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fopen_addr = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&quot;libc.so&quot;</span>, <span class="string">&quot;fopen&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> fopen = <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(fopen_addr, <span class="string">&quot;pointer&quot;</span>, [<span class="string">&quot;pointer&quot;</span>, <span class="string">&quot;pointer&quot;</span>]);</span><br><span class="line"><span class="keyword">var</span> fputs_addr = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&quot;libc.so&quot;</span>, <span class="string">&quot;fputs&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> fputs = <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(fputs_addr, <span class="string">&quot;int&quot;</span>, [<span class="string">&quot;pointer&quot;</span>, <span class="string">&quot;pointer&quot;</span>]);</span><br><span class="line"><span class="keyword">var</span> fclose_addr = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&quot;libc.so&quot;</span>, <span class="string">&quot;fclose&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> fclose = <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(fclose_addr, <span class="string">&quot;int&quot;</span>, [<span class="string">&quot;pointer&quot;</span>]);</span><br><span class="line"><span class="keyword">var</span> filename = <span class="title class_">Memory</span>.<span class="title function_">allocUtf8String</span>(<span class="string">&quot;/sdcard/a.txt&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> mod = <span class="title class_">Memory</span>.<span class="title function_">allocUtf8String</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> neirong = <span class="title class_">Memory</span>.<span class="title function_">allocUtf8String</span>(<span class="string">&quot;aaaaaaaa\r\nbbbb\r\b&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> fp = <span class="title function_">fopen</span>(filename, mod);</span><br><span class="line"><span class="title function_">fputs</span>(neirong, fp);</span><br><span class="line"><span class="title function_">fclose</span>(fp);</span><br></pre></td></tr></table></figure>

<h4 id="打印堆栈"><a href="#打印堆栈" class="headerlink" title="打印堆栈"></a>打印堆栈</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印 Java 层调用堆栈</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printJavaStack</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">Exception</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Exception&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> instance = <span class="title class_">Exception</span>.$new(<span class="string">&quot;print_stack&quot;</span>);  <span class="comment">// 创建一个 Exception 对象，构造参数用于标记用途</span></span><br><span class="line">        <span class="keyword">var</span> stack = instance.<span class="title function_">getStackTrace</span>();          <span class="comment">// 获取当前 Java 调用栈（返回 StackTraceElement[]）</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(stack);                            <span class="comment">// 打印堆栈信息（可能为数组对象）</span></span><br><span class="line">        instance.$dispose();  <span class="comment">// 释放 Java 对象，防止内存泄漏</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 native 层调用堆栈</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printNativeStack</span>(<span class="params">context, str_tag</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;\r\n=============================&quot;</span> + str_tag + <span class="string">&quot; Stack in =======================\r\n&quot;</span>);       </span><br><span class="line">    <span class="comment">// 使用 Thread.backtrace 获取 native 层调用堆栈</span></span><br><span class="line">    <span class="comment">// Backtracer.ACCURATE：使用更准确的堆栈回溯（可能性能略低）</span></span><br><span class="line">    <span class="comment">// DebugSymbol.fromAddress：将地址转换为可读的函数名等符号信息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Thread</span>.<span class="title function_">backtrace</span>(context, <span class="title class_">Backtracer</span>.<span class="property">ACCURATE</span>).<span class="title function_">map</span>(<span class="title class_">DebugSymbol</span>.<span class="property">fromAddress</span>).<span class="title function_">join</span>(<span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;\r\n=============================&quot;</span> + str_tag + <span class="string">&quot; Stack out =======================\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hook Java 方法 MainActivity.z()</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hook_java_main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> cls_act = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;a.b.k0805.MainActivity&quot;</span>);  <span class="comment">// 获取 MainActivity 类</span></span><br><span class="line">        <span class="keyword">var</span> fun_z = cls_act.<span class="property">z</span>.<span class="title function_">overload</span>();                 <span class="comment">// 获取无参 z() 方法的重载</span></span><br><span class="line">        fun_z.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hook java z() in&quot;</span>);  <span class="comment">// 进入 hook</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> ret = <span class="variable language_">this</span>.<span class="title function_">z</span>();               <span class="comment">// 调用原始方法</span></span><br><span class="line"></span><br><span class="line">            <span class="title function_">printJavaStack</span>();                 <span class="comment">// 打印 Java 层堆栈</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hook java z() out&quot;</span>); <span class="comment">// 离开 hook</span></span><br><span class="line">            <span class="keyword">return</span> ret;                       <span class="comment">// 返回原始方法的结果</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hook_java_main out&quot;</span>);  <span class="comment">// 表示 Java hook 安装完成</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hook native 层函数（未导出，但知道其偏移地址）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hook_native_main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> base_so = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(<span class="string">&quot;libk0805.so&quot;</span>);  <span class="comment">// 查找模块基址</span></span><br><span class="line">    <span class="keyword">if</span> (base_so)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;base_so:&quot;</span>, base_so);  <span class="comment">// 输出基址</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> real_addr_z = base_so.<span class="title function_">add</span>(<span class="number">0x1DFD0</span>);  <span class="comment">// 假设 z() 函数偏移为 0x1DFD0，计算实际地址</span></span><br><span class="line"></span><br><span class="line">        <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(real_addr_z, &#123;</span><br><span class="line">            <span class="title function_">onEnter</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hook onEnter z()&quot;</span>);  <span class="comment">// 进入 native 函数</span></span><br><span class="line">                <span class="title function_">printNativeStack</span>(<span class="variable language_">this</span>.<span class="property">context</span>, <span class="string">&quot;current native z()&quot;</span>);  <span class="comment">// 打印 native 层堆栈</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">onLeave</span>(<span class="params">retval</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hook onLeave z()&quot;</span>);  <span class="comment">// 离开 native 函数</span></span><br><span class="line">                <span class="comment">// 可选：console.log(&quot;Return value:&quot;, retval);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hook_native_main out&quot;</span>);  <span class="comment">// 表示 native hook 安装完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟 2 秒后执行 native hook（避免模块未加载）</span></span><br><span class="line"><span class="built_in">setTimeout</span>(hook_native_main, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// （可选）你可以根据需要启用 Java hook，例如在 onCreate 中调用：</span></span><br><span class="line"><span class="title function_">hook_java_main</span>();</span><br></pre></td></tr></table></figure>

<h4 id="使用frida-追踪jni函数动静态注册"><a href="#使用frida-追踪jni函数动静态注册" class="headerlink" title="使用frida 追踪jni函数动静态注册"></a>使用frida 追踪jni函数动静态注册</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hook 一个 native 函数，并在其被调用时输出日志</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hook_one</span>(<span class="params">funName, funAddr</span>) &#123;</span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(funAddr, &#123;</span><br><span class="line">        <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(funName, <span class="string">&quot; call in&quot;</span>);  <span class="comment">// 打印函数进入日志</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retVal</span>) &#123;</span><br><span class="line">            <span class="comment">// 函数返回时未做任何操作，可扩展记录返回值等</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找所有模块中符合条件的导出函数，并对其 Hook</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hook_explorts</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> modules = <span class="title class_">Process</span>.<span class="title function_">enumerateModules</span>(); <span class="comment">// 获取所有已加载模块信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; modules.<span class="property">length</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">var</span> oneModule = modules[j];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只处理模块名包含 &quot;0808&quot; 的模块（可以是 so 文件名、进程名等）</span></span><br><span class="line">        <span class="keyword">if</span> (oneModule.<span class="property">name</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;0808&quot;</span>) == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;oneModule:&quot;</span>, oneModule.<span class="property">name</span>);  <span class="comment">// 打印被匹配模块名称</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> funList = oneModule.<span class="title function_">enumerateExports</span>(); <span class="comment">// 获取模块导出的函数列表</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; funList.<span class="property">length</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">var</span> oneFun = funList[k];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 只 Hook 函数名包含 &quot;Java_&quot; 或 &quot;getAAA&quot; 的导出函数</span></span><br><span class="line">            <span class="keyword">if</span> (oneFun.<span class="property">name</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;Java_&quot;</span>) == -<span class="number">1</span> &amp;&amp; oneFun.<span class="property">name</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;getAAA&quot;</span>) == -<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;oneFun:&quot;</span>, oneFun.<span class="property">name</span>);  <span class="comment">// 打印被匹配的函数名</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对该函数进行 Hook</span></span><br><span class="line">            <span class="title function_">hook_one</span>(oneFun.<span class="property">name</span>, oneFun.<span class="property">address</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 层执行入口</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hook_java_main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hook_java_main in&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在 Java VM 环境中执行 Native Hook 操作</span></span><br><span class="line">        <span class="title function_">hook_explorts</span>();</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hook_java_main out&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待 Java 虚拟机启动后再执行 Hook</span></span><br><span class="line"><span class="built_in">setTimeout</span>(hook_java_main, <span class="number">2000</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/categories/">Category</a></li>
        
          <li><a href="/tags/">Tag</a></li>
        
          <li><a href="/search/">Search</a></li>
        
          <li><a href="/link/">Friends</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90Android%E8%83%BD%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E7%9A%84Jar%E5%8C%85"><span class="toc-number">1.</span> <span class="toc-text">生成Android能动态加载的Jar包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDJar%E5%8C%85"><span class="toc-number">2.</span> <span class="toc-text">动态加载Jar包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NDK%E7%BC%96%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">NDK编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JNI-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.1.</span> <span class="toc-text">JNI 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NDK-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.2.</span> <span class="toc-text">NDK 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JNI-%E4%B8%8E-NDK-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.3.</span> <span class="toc-text">JNI 与 NDK 的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AAJNI%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.4.</span> <span class="toc-text">第一个JNI程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.1.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.2.</span> <span class="toc-text">引用数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">3.5.3.</span> <span class="toc-text">数据类型描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">3.5.4.</span> <span class="toc-text">Java 引用类型描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JNI-%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.5.5.</span> <span class="toc-text">JNI 方法签名格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JNI%E6%96%B9%E6%B3%95"><span class="toc-number">3.6.</span> <span class="toc-text">JNI方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JNI%E6%B3%A8%E5%86%8C"><span class="toc-number">3.7.</span> <span class="toc-text">JNI注册</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%B3%A8%E5%86%8C"><span class="toc-number">3.7.1.</span> <span class="toc-text">静态注册</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C"><span class="toc-number">3.7.2.</span> <span class="toc-text">动态注册</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RegisterNatives%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="toc-number">3.7.2.1.</span> <span class="toc-text">RegisterNatives方法解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-mk-%E5%92%8C-CMake-%E8%AF%AD%E6%B3%95"><span class="toc-number">3.8.</span> <span class="toc-text">Android.mk 和 CMake 语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-Studio-%E4%B8%AD%E4%BD%BF%E7%94%A8-NDK"><span class="toc-number">3.9.</span> <span class="toc-text">Android Studio 中使用 NDK</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APK%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">APK文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#assets%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">4.1.</span> <span class="toc-text">assets文件夹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lib%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">4.2.</span> <span class="toc-text">lib文件夹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#META-INF%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">4.3.</span> <span class="toc-text">META-INF文件夹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AndroidManifest-xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">4.4.</span> <span class="toc-text">AndroidManifest.xml配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resources-arsc%E6%96%87%E4%BB%B6"><span class="toc-number">4.5.</span> <span class="toc-text">resources.arsc文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#res%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">4.6.</span> <span class="toc-text">res文件夹</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dex%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">dex文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string-ids"><span class="toc-number">5.1.</span> <span class="toc-text">string_ids</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-ids"><span class="toc-number">5.2.</span> <span class="toc-text">type_ids</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proto-ids"><span class="toc-number">5.3.</span> <span class="toc-text">proto_ids</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#field-ids"><span class="toc-number">5.4.</span> <span class="toc-text">field_ids</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#method-ids"><span class="toc-number">5.5.</span> <span class="toc-text">method_ids</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#class-def"><span class="toc-number">5.6.</span> <span class="toc-text">class_def</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DefCLassData"><span class="toc-number">5.6.1.</span> <span class="toc-text">DefCLassData</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DexField"><span class="toc-number">5.6.2.</span> <span class="toc-text">DexField</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DexMethod"><span class="toc-number">5.6.3.</span> <span class="toc-text">DexMethod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DexCode"><span class="toc-number">5.6.4.</span> <span class="toc-text">DexCode</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">6.</span> <span class="toc-text">ELF文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ELF-Header"><span class="toc-number">6.1.</span> <span class="toc-text">ELF Header</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Program-Header"><span class="toc-number">6.2.</span> <span class="toc-text">Program Header</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Base-Address"><span class="toc-number">6.2.1.</span> <span class="toc-text">Base Address</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#p-type"><span class="toc-number">6.2.2.</span> <span class="toc-text">p_type</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Section-Header"><span class="toc-number">6.3.</span> <span class="toc-text">Section Header</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sh-type"><span class="toc-number">6.3.1.</span> <span class="toc-text">sh_type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sh-flags"><span class="toc-number">6.3.2.</span> <span class="toc-text">sh_flags</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Program-Header-%E5%92%8C-Section-header%E5%8C%BA%E5%88%AB"><span class="toc-number">6.4.</span> <span class="toc-text">Program Header 和 Section header区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Smali%E6%B1%87%E7%BC%96"><span class="toc-number">7.</span> <span class="toc-text">Smali汇编</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.1.</span> <span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">7.2.</span> <span class="toc-text">类的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">7.3.</span> <span class="toc-text">函数声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">7.4.</span> <span class="toc-text">函数返回关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">7.5.</span> <span class="toc-text">构造函数声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">7.6.</span> <span class="toc-text">变量声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">7.7.</span> <span class="toc-text">常量声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">7.8.</span> <span class="toc-text">静态代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">7.9.</span> <span class="toc-text">函数调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E5%8F%96%E5%80%BC%E4%B8%8E%E8%B5%8B%E5%80%BC"><span class="toc-number">7.10.</span> <span class="toc-text">字段取值与赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Smali%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%96%E5%80%BC%E4%B8%8E%E8%B5%8B%E5%80%BC"><span class="toc-number">7.11.</span> <span class="toc-text">Smali数组的取值与赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Smali%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA"><span class="toc-number">7.12.</span> <span class="toc-text">Smali对象创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Smali%E5%B8%B8%E9%87%8F%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89"><span class="toc-number">7.13.</span> <span class="toc-text">Smali常量数据定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Smali%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">7.13.1.</span> <span class="toc-text">Smali字符串常量定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Smali%E5%AD%97%E8%8A%82%E7%A0%81%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">7.13.2.</span> <span class="toc-text">Smali字节码常量定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Smali%E6%95%B0%E5%80%BC%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">7.13.3.</span> <span class="toc-text">Smali数值常量定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Smali%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC"><span class="toc-number">7.14.</span> <span class="toc-text">Smali条件跳转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Smali%E9%80%BB%E8%BE%91%E5%BE%AA%E7%8E%AF"><span class="toc-number">7.15.</span> <span class="toc-text">Smali逻辑循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">7.16.</span> <span class="toc-text">寄存器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARM%E6%B1%87%E7%BC%96"><span class="toc-number">8.</span> <span class="toc-text">ARM汇编</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3"><span class="toc-number">8.1.</span> <span class="toc-text">寄存器详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">8.1.0.1.</span> <span class="toc-text">1. 通用寄存器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%B8%93%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">8.1.0.2.</span> <span class="toc-text">2. 专用寄存器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">8.1.0.3.</span> <span class="toc-text">3. 控制寄存器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-32%E4%BD%8D%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="toc-number">8.1.1.</span> <span class="toc-text">2.1 32位数据操作指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-32%E4%BD%8D%E5%AD%98%E5%82%A8%E5%99%A8%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-number">8.1.2.</span> <span class="toc-text">2.2 32位存储器数据传送指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-32%E4%BD%8D%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">8.1.3.</span> <span class="toc-text">2.3 32位转移指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E5%85%B6%E5%AE%8332%E4%BD%8D%E6%8C%87%E4%BB%A4"><span class="toc-number">8.1.4.</span> <span class="toc-text">2.4 其它32位指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E7%AB%8B%E5%8D%B3%E6%95%B0"><span class="toc-number">8.1.5.</span> <span class="toc-text">2.5 立即数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E9%80%BB%E8%BE%91%E6%95%B0"><span class="toc-number">8.1.6.</span> <span class="toc-text">2.6 逻辑数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E5%92%8C%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="toc-number">8.1.7.</span> <span class="toc-text">2.7 逻辑运算和算术运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3"><span class="toc-number">8.2.</span> <span class="toc-text">实例讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-MRS"><span class="toc-number">8.2.1.</span> <span class="toc-text">3.1 MRS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-MSR"><span class="toc-number">8.2.2.</span> <span class="toc-text">3.2 MSR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-PRIMASK"><span class="toc-number">8.2.3.</span> <span class="toc-text">3.3 PRIMASK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-FAULTMASK"><span class="toc-number">8.2.4.</span> <span class="toc-text">3.4 FAULTMASK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-BX%E6%8C%87%E4%BB%A4"><span class="toc-number">8.2.5.</span> <span class="toc-text">3.5 BX指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E9%9B%B6%E5%AF%84%E5%AD%98%E5%99%A8-wzr%E3%80%81xzr"><span class="toc-number">8.2.6.</span> <span class="toc-text">3.6 零寄存器 wzr、xzr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80%E6%8C%87%E4%BB%A4MOV"><span class="toc-number">8.2.7.</span> <span class="toc-text">3.7 立即寻址指令MOV</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%8C%87%E4%BB%A4LDR"><span class="toc-number">8.2.8.</span> <span class="toc-text">3.8 寄存器间接寻址指令LDR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-%E5%AF%84%E5%AD%98%E5%99%A8%E7%A7%BB%E4%BD%8D%E5%AF%BB%E5%9D%80%E6%8C%87%E4%BB%A4LSL"><span class="toc-number">8.2.9.</span> <span class="toc-text">3.9 寄存器移位寻址指令LSL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80%E6%8C%87%E4%BB%A4-STR"><span class="toc-number">8.2.10.</span> <span class="toc-text">3.10 基址寻址指令 STR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-%E5%A4%9A%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">8.2.11.</span> <span class="toc-text">3.11 多寄存器寻址指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BBB%EF%BC%8CBAL"><span class="toc-number">8.2.12.</span> <span class="toc-text">3.12 无条件转移B，BAL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13-%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BBB-cont"><span class="toc-number">8.2.13.</span> <span class="toc-text">3.13 条件转移B.cont</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-14-WFE-%E5%92%8C-WFI-%E5%AF%B9%E6%AF%94"><span class="toc-number">8.2.14.</span> <span class="toc-text">3.14 WFE 和 WFI 对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-15-MRC%EF%BC%9A%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%B0ARM%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-number">8.2.15.</span> <span class="toc-text">3.15 MRC：协处理器寄存器到ARM寄存器的数据传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-16-MCR%EF%BC%9A%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%B0%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-number">8.2.16.</span> <span class="toc-text">3.16 MCR：寄存器到协处理器寄存器的数据传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-17-STM%EF%BC%9A%E5%B0%86%E6%8C%87%E4%BB%A4%E4%B8%AD%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%90%84%E5%AF%84%E5%AD%98%E5%99%A8%E6%95%B0%E5%80%BC%E5%86%99%E5%85%A5%E5%88%B0%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83%E4%B8%AD"><span class="toc-number">8.2.17.</span> <span class="toc-text">3.17 STM：将指令中寄存器列表中的各寄存器数值写入到连续的内存单元中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-18-LDM%EF%BC%9A%E5%B0%86%E6%95%B0%E6%8D%AE%E4%BB%8E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%88%B0%E6%8C%87%E4%BB%A4%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%90%84%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD"><span class="toc-number">8.2.18.</span> <span class="toc-text">3.18 LDM：将数据从连续内存单元中读取到指令的寄存器列表中的各寄存器中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-19-LDR%EF%BC%9A%E4%BB%8E%E5%86%85%E5%AD%98%E4%B8%AD%E5%B0%86%E4%B8%80%E4%B8%AA32%E4%BD%8D%E7%9A%84%E5%AD%97%E8%AF%BB%E5%8F%96%E5%88%B0%E7%9B%AE%E6%A0%87%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">8.2.19.</span> <span class="toc-text">3.19 LDR：从内存中将一个32位的字读取到目标寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-20-STR%EF%BC%9A%E5%B0%8632%E4%BD%8D%E5%AD%97%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9A%84%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83"><span class="toc-number">8.2.20.</span> <span class="toc-text">3.20 STR：将32位字数据写入到指定的内存单元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-21-SWI%EF%BC%9A%E8%BD%AF%E4%B8%AD%E6%96%AD%E6%8C%87%E4%BB%A4"><span class="toc-number">8.2.21.</span> <span class="toc-text">3.21 SWI：软中断指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-22-BIC%E6%B8%85%E9%99%A4%E4%BD%8D"><span class="toc-number">8.2.22.</span> <span class="toc-text">3.22 BIC清除位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-23-EOR%E9%80%BB%E8%BE%91%E5%BC%82%E6%88%96%E6%8C%87%E4%BB%A4"><span class="toc-number">8.2.23.</span> <span class="toc-text">3.23 EOR逻辑异或指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-24-CMN%E4%B8%8E%E8%B4%9F%E6%95%B0%E5%AF%B9%E6%AF%94"><span class="toc-number">8.2.24.</span> <span class="toc-text">3.24 CMN与负数对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-25-MVN%E5%8F%96%E5%8F%8D"><span class="toc-number">8.2.25.</span> <span class="toc-text">3.25 MVN取反</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-26-LSL%EF%BC%88Logical-Shift-Left%EF%BC%89%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97"><span class="toc-number">8.2.26.</span> <span class="toc-text">3.26 LSL（Logical Shift Left）左移运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-27-STP"><span class="toc-number">8.2.27.</span> <span class="toc-text">3.27 STP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90"><span class="toc-number">8.3.</span> <span class="toc-text">实例解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E5%9F%BA%E7%A1%80"><span class="toc-number">9.</span> <span class="toc-text">Android系统源码基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-number">9.1.</span> <span class="toc-text">系统架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">9.1.1.</span> <span class="toc-text">应用层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6%E5%B1%82"><span class="toc-number">9.1.2.</span> <span class="toc-text">应用框架层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E5%BA%93%E5%B1%82"><span class="toc-number">9.1.3.</span> <span class="toc-text">系统运行库层</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Android-Runtime%EF%BC%88ART%EF%BC%89"><span class="toc-number">9.1.3.1.</span> <span class="toc-text">Android Runtime（ART）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-C-%E5%8E%9F%E7%94%9F%E5%BA%93%EF%BC%88Native-Libraries%EF%BC%89"><span class="toc-number">9.1.3.2.</span> <span class="toc-text">C&#x2F;C++ 原生库（Native Libraries）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%8A%BD%E8%B1%A1%E5%B1%82"><span class="toc-number">9.1.4.</span> <span class="toc-text">硬件抽象层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E5%86%85%E6%A0%B8%E5%B1%82"><span class="toc-number">9.1.5.</span> <span class="toc-text">Linux内核层</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">9.2.</span> <span class="toc-text">源码目录结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Frida-%E4%BD%BF%E7%94%A8"><span class="toc-number">10.</span> <span class="toc-text">Frida 使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC%E6%B3%A8%E5%85%A5%E5%88%B0Android%E7%9B%AE%E6%A0%87%E8%BF%9B%E7%A8%8B"><span class="toc-number">10.1.</span> <span class="toc-text">将一个脚本注入到Android目标进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hook-Java"><span class="toc-number">10.2.</span> <span class="toc-text">Hook Java</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">10.2.1.</span> <span class="toc-text">带参数的构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">10.2.2.</span> <span class="toc-text">无参数构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E5%87%BD%E6%95%B0"><span class="toc-number">10.2.3.</span> <span class="toc-text">一般函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">10.2.4.</span> <span class="toc-text">无参数的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">10.2.5.</span> <span class="toc-text">调用函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E6%93%8D%E4%BD%9C"><span class="toc-number">10.2.6.</span> <span class="toc-text">字段操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">10.2.7.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-available%E5%AD%97%E6%AE%B5"><span class="toc-number">10.2.8.</span> <span class="toc-text">Java.available字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-perform%E6%96%B9%E6%B3%95"><span class="toc-number">10.2.9.</span> <span class="toc-text">Java.perform方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hook-Native"><span class="toc-number">10.3.</span> <span class="toc-text">Hook Native</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Hook-Native%E5%B1%82%E4%B8%AD%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%B9%B6%E4%B8%94%E8%AF%BB%E5%8F%96%E4%BC%A0%E5%85%A5%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">10.3.1.</span> <span class="toc-text">Hook Native层中调用的函数并且读取传入的参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hook%E4%BF%AE%E6%94%B9native%E5%B1%82%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">10.3.2.</span> <span class="toc-text">Hook修改native层程序返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8native%E5%B1%82%E4%B8%AD%E6%9C%AA%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">10.3.3.</span> <span class="toc-text">调用native层中未被调用的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8native%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">10.3.4.</span> <span class="toc-text">主动调用native中的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E5%A0%86%E6%A0%88"><span class="toc-number">10.3.5.</span> <span class="toc-text">打印堆栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8frida-%E8%BF%BD%E8%B8%AAjni%E5%87%BD%E6%95%B0%E5%8A%A8%E9%9D%99%E6%80%81%E6%B3%A8%E5%86%8C"><span class="toc-number">10.3.6.</span> <span class="toc-text">使用frida 追踪jni函数动静态注册</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/&text=Android基础"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/&title=Android基础"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/&is_video=false&description=Android基础"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Android基础&body=Check out this article: https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/&title=Android基础"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/&title=Android基础"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/&title=Android基础"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/&title=Android基础"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/&name=Android基础&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://oceanzbz.cn/2025/04/09/%E5%BC%80%E5%8F%91/%E5%AE%89%E5%8D%93/Android%E5%9F%BA%E7%A1%80/&t=Android基础"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2025
    Oceanzbz
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/link/">Friends</a></li><!--
     -->
      </ul>
      <ul>
        
          <!-- 不蒜子统计 -->
          <span id="busuanzi_container_site_pv">
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
          </span>
          <span class="post-meta-divider">|</span>
          <span id="busuanzi_container_site_uv" style='display:none'>
                  本站访客数<span id="busuanzi_value_site_uv"></span>人
          </span>
          <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        
      </ul>
    </nav>
  </div>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-QWTJSPQL4F"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-QWTJSPQL4F');
</script>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'cactus-1';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

</body>
</html>
